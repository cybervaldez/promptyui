<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>PromptyUI — Landing Preview</title>
<link rel="stylesheet" href="/vendor/quill/quill.snow.css">
<style>
:root {
    --bg-deep: #0a0a0a;
    --bg-surface: #161b22;
    --bg-elevated: #1c2128;
    --text-primary: #e6edf3;
    --text-secondary: #8b949e;
    --text-muted: #484f58;
    --accent-green: #3fb950;
    --accent-green-dim: rgba(63, 185, 80, 0.15);
    --accent-amber: #ff6b35;
    --accent-amber-dim: rgba(255, 107, 53, 0.15);
    --accent-blue: #58a6ff;
    --accent-blue-dim: rgba(88, 166, 255, 0.15);
    --accent-purple: #bc8cff;
    --accent-purple-dim: rgba(188, 140, 255, 0.15);
    --reel-label: #e8943a;
    --reel-value: #529CCA;
    --reel-bg: rgba(82, 156, 202, 0.08);
    --font-mono: 'Courier New', Courier, monospace;
}

*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

body {
    font-family: var(--font-mono);
    background: var(--bg-deep);
    color: var(--text-primary);
    overflow-x: hidden;
    overflow-y: auto;
}

/* ── Section 1: Hero ── */
.hero-section {
    height: 100vh;
    position: relative;
    overflow: hidden;
}

.viewport {
    display: flex;
    flex-direction: column;
    height: 100%;
}

.editor-zone {
    flex: 6;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    padding: 1rem 4rem;
    position: relative;
    overflow: visible;
}

.editor-lines {
    width: 100%;
    max-width: 750px;
    min-width: 580px;
    min-height: 22em;
}

.divider {
    height: 1px;
    background: linear-gradient(90deg, transparent 5%, var(--text-muted) 50%, transparent 95%);
    opacity: 0.25;
}

.math-zone {
    flex: 4;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: 1.5rem 2rem;
    position: relative;
}

/* ── Editor lines (shared hero + demo) ── */
.editor-line {
    font-size: clamp(0.85rem, 1.8vw, 1.1rem);
    line-height: 2.6em;
    white-space: nowrap;
    overflow: visible;
    color: var(--text-secondary);
    margin-top: 0.4em;
    transition: opacity 0.5s ease;
}

.editor-line.dimmed {
    opacity: 0.12;
}

/* Wildcard placeholder — dormant reel block (name visible, no window) */
.wc-placeholder {
    display: inline-block;
    vertical-align: middle;
    padding: 0 8px;
    border-radius: 4px;
    background: var(--reel-bg);
    color: var(--reel-label);
    height: 1.6em;
    line-height: 1.6em;
    text-align: center;
    white-space: nowrap;
}

.editor-line--child {
    padding-left: 2ch;
    opacity: 0;
    transform: translateY(8px);
    transition: opacity 0.5s ease, transform 0.5s ease;
}

.editor-line--child.visible {
    opacity: 1;
    transform: translateY(0);
}

.tree-connector {
    color: var(--text-muted);
    user-select: none;
}

/* ── Inline reel (shared hero + demo) ── */
.reel {
    display: inline-block;
    position: relative;
    vertical-align: middle;
    padding: 0 8px;
    border-radius: 4px;
    background: var(--reel-bg);
    overflow: visible;
    height: 1.6em;
    line-height: 1.6em;
}

.reel.interactive {
    cursor: pointer;
    transition: background 0.2s ease;
}

.reel.interactive:hover {
    background: rgba(82, 156, 202, 0.18);
}

.reel.interactive.popover-open {
    background: rgba(82, 156, 202, 0.22);
    outline: 1px solid rgba(82, 156, 202, 0.3);
}

.reel-label {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    text-align: center;
    color: var(--reel-label);
    font-size: inherit;
    line-height: 1.6em;
    white-space: nowrap;
    z-index: 2;
    pointer-events: none;
    transform-origin: center center;
    transform: translateY(0) scale(1);
    opacity: 1;
    transition: transform 0.6s cubic-bezier(0.4, 0, 0.2, 1),
                opacity 0.15s ease;
}

.reel-label.float {
    transform: translateY(-1.3em) scale(0.55);
    opacity: 1;
}

.reel-window {
    display: block;
    overflow: hidden;
    width: 100%;
    height: 0;
    transition: height 0.4s cubic-bezier(0.4, 0, 0.2, 1);
    -webkit-mask-image: linear-gradient(to bottom, transparent 0%, black 15%, black 85%, transparent 100%);
    mask-image: linear-gradient(to bottom, transparent 0%, black 15%, black 85%, transparent 100%);
}

.reel-window.open {
    height: 1.6em;
}

.reel-track {
    display: flex;
    flex-direction: column;
    align-items: center;
    opacity: 0;
    transition: transform 0.8s cubic-bezier(0.22, 1, 0.36, 1),
                opacity 0.4s ease;
}

.reel-track.visible {
    opacity: 1;
}

.reel-item {
    white-space: nowrap;
    font-size: inherit;
    color: var(--reel-value);
    line-height: 1.6em;
    height: 1.6em;
    display: flex;
    align-items: center;
    justify-content: center;
}

/* ── Math zone: formula mode ── */
.math-formula-area {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 0.4rem;
    transition: opacity 0.6s ease;
}

.math-formula, .demo-formula {
    font-size: clamp(0.75rem, 1.4vw, 1rem);
    color: var(--text-muted);
    display: flex;
    align-items: center;
    gap: 0.5ch;
    flex-wrap: wrap;
    justify-content: center;
}

.formula-term {
    font-weight: 500;
    opacity: 0;
    transform: translateX(10px);
    transition: opacity 0.4s ease, transform 0.4s ease;
}

.formula-term.visible {
    opacity: 1;
    transform: translateX(0);
}

.formula-count {
    opacity: 0.55;
}

.formula-x {
    color: var(--text-muted);
    opacity: 0;
    transition: opacity 0.3s ease;
}

.formula-x.visible {
    opacity: 1;
}

/* ── Big odometer count (shared) ── */
.math-big-count, .demo-count {
    font-size: clamp(3rem, 8vw, 6rem);
    font-weight: 700;
    color: var(--accent-amber);
    display: flex;
    align-items: center;
    justify-content: center;
    line-height: 1;
}

.odo-wrap {
    display: inline-block;
    height: 1em;
    overflow: hidden;
    line-height: 1;
}

.odo-strip { display: block; }

.odo-d {
    display: block;
    height: 1em;
    line-height: 1;
    text-align: center;
}

.odo-comma { line-height: 1; }

.math-label {
    font-size: 0.8rem;
    color: var(--text-muted);
    letter-spacing: 0.12em;
    text-transform: uppercase;
    opacity: 0;
    transition: opacity 0.4s ease;
}

.math-label.visible {
    opacity: 1;
}

/* ── Scroll indicator ── */
.scroll-indicator {
    position: absolute;
    bottom: 2rem;
    left: 50%;
    transform: translateX(-50%);
    color: var(--text-muted);
    font-size: 1.4rem;
    opacity: 0;
    transition: opacity 0.6s ease;
    animation: bounce 2s ease-in-out infinite;
    cursor: pointer;
}

.scroll-indicator.visible {
    opacity: 0.6;
}

.scroll-indicator:hover {
    opacity: 1;
}

@keyframes bounce {
    0%, 100% { transform: translateX(-50%) translateY(0); }
    50% { transform: translateX(-50%) translateY(8px); }
}

/* ══════════════════════════════════════
   Section 2: Interactive Demo
   ══════════════════════════════════════ */
.demo-section {
    min-height: 100vh;
    position: relative;
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 6rem 2rem 4rem;
    border-top: 1px solid rgba(72, 79, 88, 0.2);
}

.demo-title {
    font-size: clamp(1.2rem, 3vw, 1.8rem);
    font-weight: 600;
    color: var(--text-primary);
    margin-bottom: 0.4rem;
}

.demo-subtitle {
    font-size: clamp(0.75rem, 1.4vw, 0.9rem);
    color: var(--text-muted);
    margin-bottom: 2.5rem;
}

.demo-editor-area {
    width: 100%;
    max-width: 700px;
    background: var(--bg-surface);
    border: 1px solid rgba(72, 79, 88, 0.3);
    border-radius: 8px;
    padding: 1.5rem 2rem;
    position: relative;
}

.demo-lines {
    min-height: 6em;
}

.demo-actions {
    display: flex;
    gap: 0.8rem;
    margin-top: 1rem;
    padding-top: 1rem;
    border-top: 1px solid rgba(72, 79, 88, 0.2);
}

.demo-btn {
    font-family: var(--font-mono);
    font-size: 0.8rem;
    color: var(--text-muted);
    background: transparent;
    border: 1px dashed rgba(72, 79, 88, 0.4);
    border-radius: 4px;
    padding: 0.3em 0.8em;
    cursor: pointer;
    transition: color 0.2s, border-color 0.2s;
}

.demo-btn:hover {
    color: var(--reel-value);
    border-color: var(--reel-value);
}

.demo-formula-area {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 0.4rem;
    margin-top: 2.5rem;
}

.demo-count {
    font-size: clamp(2rem, 5vw, 3.5rem);
}

.demo-cta {
    display: inline-block;
    margin-top: 2.5rem;
    font-family: var(--font-mono);
    font-size: 1rem;
    color: var(--bg-deep);
    background: var(--accent-amber);
    text-decoration: none;
    padding: 0.7em 2em;
    border-radius: 6px;
    font-weight: 600;
    transition: transform 0.2s, box-shadow 0.2s;
}

.demo-cta:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 20px rgba(255, 107, 53, 0.3);
}

/* ── Value popover ── */
.wc-popover {
    position: fixed;
    z-index: 100;
    background: var(--bg-elevated);
    border: 1px solid rgba(72, 79, 88, 0.5);
    border-radius: 8px;
    padding: 0.8rem;
    min-width: 200px;
    max-width: 320px;
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
}

.wc-popover-name {
    font-size: 0.7rem;
    color: var(--reel-label);
    text-transform: uppercase;
    letter-spacing: 0.1em;
    margin-bottom: 0.5rem;
}

.wc-popover-pills {
    display: flex;
    flex-wrap: wrap;
    gap: 0.3rem;
    margin-bottom: 0.5rem;
}

.wc-pill {
    display: inline-flex;
    align-items: center;
    gap: 0.3em;
    font-size: 0.8rem;
    color: var(--reel-value);
    background: rgba(82, 156, 202, 0.1);
    border: 1px solid rgba(82, 156, 202, 0.2);
    border-radius: 3px;
    padding: 0.15em 0.4em;
}

.wc-pill-remove {
    cursor: pointer;
    color: var(--text-muted);
    font-size: 0.9em;
    line-height: 1;
    transition: color 0.15s;
}

.wc-pill-remove:hover {
    color: #f85149;
}

.wc-popover-input {
    width: 100%;
    font-family: var(--font-mono);
    font-size: 0.8rem;
    color: var(--text-primary);
    background: var(--bg-deep);
    border: 1px solid rgba(72, 79, 88, 0.4);
    border-radius: 4px;
    padding: 0.35em 0.5em;
    outline: none;
}

.wc-popover-input:focus {
    border-color: var(--reel-value);
}

.wc-popover-input::placeholder {
    color: var(--text-muted);
    font-size: 0.75rem;
}

/* ── Demo child input ── */
.demo-child-input {
    color: var(--text-primary);
    outline: none;
    min-width: 12ch;
    border-bottom: 1px dashed var(--text-muted);
    padding: 0 0.2em;
}

.demo-child-input:empty::before {
    content: attr(data-placeholder);
    color: var(--text-muted);
    font-size: 0.85em;
}

/* ══════════════════════════════════════
   Section 3: Quill Editor
   ══════════════════════════════════════ */
.quill-section {
    min-height: 100vh;
    position: relative;
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 6rem 2rem 4rem;
    border-top: 1px solid rgba(72, 79, 88, 0.2);
}

.quill-title {
    font-size: clamp(1.2rem, 3vw, 1.8rem);
    font-weight: 600;
    color: var(--text-primary);
    margin-bottom: 0.4rem;
}

.quill-subtitle {
    font-size: clamp(0.75rem, 1.4vw, 0.9rem);
    color: var(--text-muted);
    margin-bottom: 2.5rem;
}

.quill-editor-area {
    width: 100%;
    max-width: 700px;
    background: var(--bg-surface);
    border: 1px solid rgba(72, 79, 88, 0.3);
    border-radius: 8px;
    padding: 1.5rem 2rem;
    position: relative;
}

.quill-blocks {
    min-height: 6em;
}

/* ── Block wrapper ── */
.q-block {
    position: relative;
    margin-bottom: 0.3em;
}

.q-block-view {
    cursor: text;
    padding: 0.2em 0;
    border-radius: 4px;
    transition: background 0.15s;
}

.q-block-view:hover {
    background: rgba(72, 79, 88, 0.1);
}

.q-block-edit {
    display: none;
}

.q-block.editing .q-block-view { display: none; }
.q-block.editing .q-block-edit { display: flex; align-items: baseline; }

/* ── Edit-mode tree connector ── */
.q-edit-connector {
    color: var(--text-muted);
    user-select: none;
    white-space: nowrap;
    line-height: 2.6em;
    flex-shrink: 0;
    padding-left: 2ch;
}

.q-quill-wrap {
    flex: 1;
    min-width: 0;
}

/* ── Quill overrides: block edit (seamless with view) ── */
.q-block-edit .ql-container.ql-snow {
    border: none;
    font-family: var(--font-mono);
    font-size: clamp(0.85rem, 1.8vw, 1.1rem);
    background: transparent;
}

.q-block-edit .ql-editor {
    color: var(--text-secondary);
    padding: 0.2em 0;
    min-height: auto;
    line-height: 2.6em;
    caret-color: var(--accent-amber);
}

.q-block-edit .ql-editor.ql-blank::before {
    color: var(--text-muted);
    font-style: normal;
}

/* ── Quill overrides: persistent input ── */
.q-persistent-input {
    margin-top: 0.5em;
    padding-top: 0.5em;
    border-top: 1px dashed rgba(72, 79, 88, 0.3);
}

.q-persistent-input .ql-container.ql-snow {
    border: 1px dashed rgba(72, 79, 88, 0.4);
    border-radius: 4px;
    font-family: var(--font-mono);
    font-size: clamp(0.85rem, 1.8vw, 1.1rem);
    background: transparent;
}

.q-persistent-input .ql-editor {
    color: var(--text-primary);
    padding: 0.4em 0.6em;
    min-height: 2em;
    line-height: 2em;
    caret-color: var(--accent-amber);
}

.q-persistent-input .ql-editor.ql-blank::before {
    color: var(--text-muted);
    font-style: normal;
}

/* ── Wildcard chip in Quill (matches view-mode reel) ── */
.ql-wildcard-chip {
    display: inline-block;
    position: relative;
    vertical-align: middle;
    padding: 0 8px;
    border-radius: 4px;
    background: var(--reel-bg);
    cursor: default;
    height: 1.6em;
    line-height: 1.6em;
    overflow: visible;
}

.ql-wc-label {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    text-align: center;
    color: var(--reel-label);
    font-family: var(--font-mono);
    font-size: inherit;
    line-height: 1.6em;
    white-space: nowrap;
    pointer-events: none;
    transform: translateY(-1.3em) scale(0.55);
    transform-origin: center center;
}

.ql-wc-value {
    color: var(--reel-value);
    font-family: var(--font-mono);
    font-size: inherit;
    white-space: nowrap;
}

/* ── Quill formula area ── */
.quill-formula-area {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 0.4rem;
    margin-top: 2.5rem;
}

.quill-count {
    font-size: clamp(2rem, 5vw, 3.5rem);
}

/* ── Responsive ── */
@media (max-width: 768px) {
    .editor-zone { padding: 2rem 1.5rem; }
    .editor-lines { min-width: 0; }
    .editor-line--child { padding-left: 1.5ch; }
    .math-big-count { font-size: clamp(2rem, 6vw, 4rem); }
    .demo-section { padding: 4rem 1rem 3rem; }
    .demo-editor-area { padding: 1rem; }
    .quill-section { padding: 4rem 1rem 3rem; }
    .quill-editor-area { padding: 1rem; }
}
</style>
</head>
<body>

<!-- ═══════════════════════════════════════════
     SECTION 1: Hero Animation
     ═══════════════════════════════════════════ -->
<section class="hero-section">
    <div class="viewport">
        <div class="editor-zone">
            <div class="editor-lines" id="editor-lines"></div>
        </div>
        <div class="divider"></div>
        <div class="math-zone" id="math-zone">
            <div class="math-formula-area" id="math-formula-area" style="opacity: 0;">
                <div class="math-formula" id="math-formula"></div>
                <div class="math-big-count" id="math-big-count"></div>
                <div class="math-label" id="math-label">compositions</div>
            </div>
        </div>
    </div>
    <div class="scroll-indicator" id="scroll-indicator">&#8595; try it yourself</div>
</section>

<!-- ═══════════════════════════════════════════
     SECTION 2: Interactive Demo
     ═══════════════════════════════════════════ -->
<section class="demo-section" id="demo-section">
    <h2 class="demo-title">Now try it yourself</h2>
    <p class="demo-subtitle">Click a wildcard block to edit its values</p>

    <div class="demo-editor-area" data-testid="demo-editor-area">
        <div class="demo-lines" id="demo-lines"></div>
        <div class="demo-actions">
            <button class="demo-btn" id="btn-add-child" data-testid="btn-add-child">+ Add Child</button>
            <button class="demo-btn" id="btn-add-wildcard" data-testid="btn-add-wildcard">+ Add Wildcard</button>
        </div>
    </div>

    <div class="demo-formula-area">
        <div class="demo-formula" id="demo-formula"></div>
        <div class="demo-count" id="demo-count" data-testid="demo-count"></div>
        <div class="math-label" id="demo-label">compositions</div>
    </div>

    <a href="#" class="demo-cta" data-testid="demo-cta">Start Building &rarr;</a>

    <!-- Value popover (shared, fixed positioned) -->
    <div class="wc-popover" id="wc-popover" style="display: none;" data-testid="wc-popover">
        <div class="wc-popover-name"></div>
        <div class="wc-popover-pills"></div>
        <input class="wc-popover-input" type="text" placeholder="add values, comma separated" data-testid="wc-popover-input">
    </div>
</section>

<!-- ═══════════════════════════════════════════
     SECTION 3: Quill Editor
     ═══════════════════════════════════════════ -->
<section class="quill-section" id="quill-section">
    <h2 class="quill-title">Quill Editor</h2>
    <p class="quill-subtitle">Click a block to edit &middot; Type __name__ for wildcards</p>

    <div class="quill-editor-area" data-testid="quill-editor-area">
        <div class="quill-blocks" id="quill-blocks"></div>
        <div class="q-persistent-input">
            <div id="quill-persistent-editor"></div>
        </div>
    </div>

    <div class="quill-formula-area">
        <div class="demo-formula" id="quill-formula"></div>
        <div class="demo-count quill-count" id="quill-count" data-testid="quill-count"></div>
        <div class="math-label visible" id="quill-label">compositions</div>
    </div>
</section>

<script src="/vendor/quill/quill.js"></script>
<script>
/* ══════════════════════════════════════════════════
   DATA
   ══════════════════════════════════════════════════ */
var SEASONS = ['autumn', 'winter', 'spring', 'summer'];
var STYLES = ['watercolor', 'oil', 'digital', 'pencil'];
var BASE = 'A cabin in the forest';

var COLORS = {
    season: { color: '#ff6b35', dim: 'rgba(255,107,53,0.15)' },
    style:  { color: '#58a6ff', dim: 'rgba(88,166,255,0.15)' },
    detail: { color: '#3fb950', dim: 'rgba(63,185,80,0.15)' },
    lighting: { color: '#bc8cff', dim: 'rgba(188,140,255,0.15)' },
    lens:   { color: '#ff6b35', dim: 'rgba(255,107,53,0.15)' },
    palette: { color: '#58a6ff', dim: 'rgba(88,166,255,0.15)' },
    era:    { color: '#3fb950', dim: 'rgba(63,185,80,0.15)' }
};

var DEMO_COLORS = ['#ff6b35', '#58a6ff', '#3fb950', '#bc8cff', '#ff6b35', '#58a6ff', '#3fb950'];

/* ══════════════════════════════════════════════════
   UTILITY
   ══════════════════════════════════════════════════ */
function wait(ms) {
    return new Promise(function(r) { setTimeout(r, ms); });
}

/* ══════════════════════════════════════════════════
   BUILD TEXT LINE — plain text with placeholder spans
   for wildcard positions. Used by hero Phase 1.
   ══════════════════════════════════════════════════ */
function buildTextLine(text, wildcards) {
    var line = document.createElement('div');
    line.className = 'editor-line';

    var sorted = wildcards.slice().sort(function(a, b) { return a.pos - b.pos; });
    var cursor = 0;

    sorted.forEach(function(wc) {
        if (wc.pos > cursor) {
            line.appendChild(document.createTextNode(text.slice(cursor, wc.pos)));
        }

        var span = document.createElement('span');
        span.className = 'wc-placeholder';
        span.setAttribute('data-wc', wc.name);
        span.textContent = wc.name;
        span.style.minWidth = (wc.name.length + 1) + 'ch';
        span._wcDef = wc;
        line.appendChild(span);

        cursor = wc.pos + wc.len;
    });

    if (cursor < text.length) {
        line.appendChild(document.createTextNode(text.slice(cursor)));
    }

    return line;
}

/* ══════════════════════════════════════════════════
   REVEAL PLACEHOLDER — swap text span for reel block
   and activate it. Returns the reel controller.
   ══════════════════════════════════════════════════ */
async function revealPlaceholder(span) {
    var wc = span._wcDef;

    // Build reel element
    var reel = document.createElement('span');
    reel.className = 'reel';
    reel.setAttribute('data-wc', wc.name);

    var label = document.createElement('span');
    label.className = 'reel-label';
    label.textContent = wc.name;
    reel.appendChild(label);

    var win = document.createElement('span');
    win.className = 'reel-window';

    var track = document.createElement('span');
    track.className = 'reel-track';

    wc.values.forEach(function(v) {
        var item = document.createElement('span');
        item.className = 'reel-item';
        item.textContent = v;
        track.appendChild(item);
    });
    var clone = document.createElement('span');
    clone.className = 'reel-item';
    clone.textContent = wc.values[0];
    track.appendChild(clone);

    win.appendChild(track);
    reel.appendChild(win);

    reel.style.minWidth = (wc.name.length + 1) + 'ch';
    reel._values = wc.values;
    reel._currentIdx = 0;
    reel._track = track;
    reel._label = label;

    // Swap placeholder for reel
    span.parentNode.replaceChild(reel, span);

    // Activate (label floats, window opens, values scroll)
    return await activateReel(reel);
}

/* ══════════════════════════════════════════════════
   ACTIVATE REEL — hero animation sequence
   ══════════════════════════════════════════════════ */
var _allReelCtrls = [];

async function activateReel(reelEl) {
    var values = reelEl._values;
    var track = reelEl._track;
    var label = reelEl._label;
    var win = reelEl.querySelector('.reel-window');
    var currentIdx = reelEl._currentIdx;

    var maxLen = 0;
    values.forEach(function(v) { if (v.length > maxLen) maxLen = v.length; });
    reelEl.style.minWidth = (maxLen + 1) + 'ch';

    label.classList.add('float');
    await wait(650);

    win.classList.add('open');

    var itemH = track.querySelector('.reel-item').offsetHeight || 26;
    track.style.transition = 'none';
    track.style.transform = 'translateY(' + itemH + 'px)';
    track.offsetHeight;
    track.classList.add('visible');

    await wait(100);
    var targetIdx = values.length - 1;
    track.style.transition = 'transform 1.2s cubic-bezier(0.22, 1, 0.36, 1)';
    track.style.transform = 'translateY(-' + (targetIdx * itemH) + 'px)';
    currentIdx = targetIdx;
    reelEl._currentIdx = targetIdx;

    function spinTo(idx) {
        var h = track.querySelector('.reel-item').offsetHeight || 26;
        track.style.transition = 'none';
        track.style.transform = 'translateY(-' + (values.length * h) + 'px)';
        track.offsetHeight;
        track.style.transition = 'transform 0.8s cubic-bezier(0.22, 1, 0.36, 1), opacity 0.4s ease';
        track.style.transform = 'translateY(-' + (idx * h) + 'px)';
        currentIdx = idx;
        reelEl._currentIdx = idx;
    }

    function spin() {
        var next = (currentIdx + 1 + Math.floor(Math.random() * (values.length - 1))) % values.length;
        spinTo(next);
    }

    var ctrl = { spin: spin, spinTo: spinTo };
    _allReelCtrls.push(ctrl);
    return ctrl;
}

/* ══════════════════════════════════════════════════
   ODOMETER — shared by hero and demo
   ══════════════════════════════════════════════════ */
function rollOdometerTo(containerEl, num, prevNum) {
    var newFormatted = num.toLocaleString();
    var newRaw = num.toString().split('').map(Number);
    var oldRaw = prevNum.toString().split('').map(Number);

    while (oldRaw.length < newRaw.length) oldRaw.unshift(0);
    while (newRaw.length < oldRaw.length) newRaw.unshift(0);

    containerEl.innerHTML = '';
    var rawIdx = 0;
    var totalDigits = newRaw.length;

    newFormatted.split('').forEach(function(ch) {
        if (ch === ',') {
            var comma = document.createElement('span');
            comma.className = 'odo-comma';
            comma.textContent = ',';
            containerEl.appendChild(comma);
            return;
        }

        var target = parseInt(ch);
        var from = oldRaw[rawIdx] || 0;
        var staggerDelay = (totalDigits - 1 - rawIdx) * 80 + 20;
        rawIdx++;

        var stripEnd = 9;
        if (target < from) {
            stripEnd = 10 + target;
        }

        var wrap = document.createElement('span');
        wrap.className = 'odo-wrap';
        var strip = document.createElement('span');
        strip.className = 'odo-strip';

        for (var n = 0; n <= stripEnd; n++) {
            var d = document.createElement('span');
            d.className = 'odo-d';
            d.textContent = n % 10;
            strip.appendChild(d);
        }

        strip.style.transform = 'translateY(' + (-from) + 'em)';
        wrap.appendChild(strip);
        containerEl.appendChild(wrap);

        (function(s, t, se, dl) {
            var animTarget = (t < from) ? se : t;
            setTimeout(function() {
                s.style.transition = 'transform 1s cubic-bezier(0.22, 1, 0.36, 1)';
                s.style.transform = 'translateY(' + (-animTarget) + 'em)';
            }, dl);
        })(strip, target, stripEnd, staggerDelay);
    });
}

/* Hero odometer wrapper (keeps backward compat) */
var _prevOdoNum = 0;
function rollOdometer(containerEl, num) {
    rollOdometerTo(containerEl, num, _prevOdoNum);
    _prevOdoNum = num;
}

/* ══════════════════════════════════════════════════
   FORMULA — hero animation
   ══════════════════════════════════════════════════ */
var formulaTerms = [];

function addFormulaTerm(name, count, color) {
    var formulaEl = document.getElementById('math-formula');

    if (formulaTerms.length > 0) {
        var x = document.createElement('span');
        x.className = 'formula-x';
        x.textContent = '\u00d7';
        formulaEl.appendChild(x);
        setTimeout(function() { x.classList.add('visible'); }, 50);
    }

    var term = document.createElement('span');
    term.className = 'formula-term';
    term.style.color = color;
    term.innerHTML = name + '<span class="formula-count">(' + count + ')</span>';
    formulaEl.appendChild(term);
    setTimeout(function() { term.classList.add('visible'); }, 150);

    formulaTerms.push({ name: name, count: count });
}

function getFormulaTotal() {
    return formulaTerms.reduce(function(a, t) { return a * t.count; }, 1);
}

/* ══════════════════════════════════════════════════
   HERO ANIMATION — runs once, no loop
   ══════════════════════════════════════════════════ */
var editorLines = document.getElementById('editor-lines');
var mathFormulaArea = document.getElementById('math-formula-area');
var mathFormula = document.getElementById('math-formula');
var mathBigCount = document.getElementById('math-big-count');
var mathLabel = document.getElementById('math-label');

async function runAnimation() {
    var connectorEls = [];
    _allReelCtrls = [];

    var allLines = [];       // every line element
    var allPlaceholders = []; // {span, lineEl, def} for reveal phase

    /* ════════════════════════════════════════════════
       PHASE 1 — Show all lines as plain text, one by one
       ════════════════════════════════════════════════ */

    // Parent line
    var promptText = BASE + ', autumn, watercolor';
    var parentWcDefs = [
        { pos: BASE.length + 2, len: 6, name: 'season', values: SEASONS },
        { pos: BASE.length + 10, len: 10, name: 'style', values: STYLES }
    ];
    var promptLine = buildTextLine(promptText, parentWcDefs);
    editorLines.appendChild(promptLine);
    allLines.push(promptLine);

    // Collect parent placeholders
    parentWcDefs.forEach(function(wd) {
        var span = promptLine.querySelector('[data-wc="' + wd.name + '"]');
        allPlaceholders.push({ span: span, lineEl: promptLine, def: wd });
    });

    await wait(600);

    // Child lines
    var allChildDefs = [
        { pre: 'with ', wc: 'detail', suf: ' level of detail',
          values: ['high', 'medium', 'sketch'] },
        { pre: 'in ', wc: 'lighting', suf: ' light',
          values: ['warm', 'cool', 'dramatic', 'natural'] },
        { pre: 'shot with ', wc: 'lens', suf: ' lens',
          values: ['35mm', '50mm', '85mm', 'macro', 'tilt-shift', 'wide'] },
        { pre: 'with ', wc: 'palette', suf: ' palette',
          values: ['vibrant', 'muted', 'earth', 'neon', 'pastel'] },
        { pre: 'in ', wc: 'era', suf: ' style',
          values: ['1920s', '1960s', '1980s', 'modern', 'futuristic', 'medieval'] }
    ];

    for (var c = 0; c < allChildDefs.length; c++) {
        var cd = allChildDefs[c];

        if (connectorEls.length > 0) {
            connectorEls[connectorEls.length - 1].textContent = '\u251C\u2500\u2500 ';
        }

        var childText = cd.pre + cd.values[0] + cd.suf;
        var childLine = buildTextLine(childText, [
            { pos: cd.pre.length, len: cd.values[0].length, name: cd.wc, values: cd.values }
        ]);
        childLine.className = 'editor-line editor-line--child';

        var conn = document.createElement('span');
        conn.className = 'tree-connector';
        conn.textContent = '\u2514\u2500\u2500 ';
        connectorEls.push(conn);
        childLine.insertBefore(conn, childLine.firstChild);

        editorLines.appendChild(childLine);
        allLines.push(childLine);

        await wait(50);
        childLine.classList.add('visible');
        await wait(300);

        var childSpan = childLine.querySelector('[data-wc="' + cd.wc + '"]');
        allPlaceholders.push({ span: childSpan, lineEl: childLine, def: cd });
    }

    await wait(800);

    /* ════════════════════════════════════════════════
       PHASE 2 — Reveal wildcards with focus effect
       Dim everything, highlight the line(s) being revealed.
       ════════════════════════════════════════════════ */

    // Helper: dim all except given lines
    function focusLines(keepLines) {
        allLines.forEach(function(l) {
            if (keepLines.indexOf(l) !== -1) {
                l.classList.remove('dimmed');
            } else {
                l.classList.add('dimmed');
            }
        });
    }

    function unfocusAll() {
        allLines.forEach(function(l) { l.classList.remove('dimmed'); });
    }

    mathFormulaArea.style.opacity = '1';
    mathLabel.classList.add('visible');

    // Parent wildcards — reveal together, focus on parent line
    var parentPlaceholders = allPlaceholders.filter(function(p) { return p.lineEl === promptLine; });
    focusLines([promptLine]);
    await wait(400);

    var parentPromises = parentPlaceholders.map(function(p) {
        addFormulaTerm(p.def.name, p.def.values.length, COLORS[p.def.name].color);
        return revealPlaceholder(p.span);
    });
    rollOdometer(mathBigCount, getFormulaTotal());
    await Promise.all(parentPromises);
    await wait(800);
    unfocusAll();
    await wait(400);

    // Child wildcards — reveal one by one, focus child + parent
    var childPlaceholders = allPlaceholders.filter(function(p) { return p.lineEl !== promptLine; });
    for (var r = 0; r < childPlaceholders.length; r++) {
        var cp = childPlaceholders[r];

        focusLines([promptLine, cp.lineEl]);
        await wait(400);

        addFormulaTerm(cp.def.wc || cp.def.name, cp.def.values.length, COLORS[cp.def.wc || cp.def.name].color);
        rollOdometer(mathBigCount, getFormulaTotal());
        await revealPlaceholder(cp.span);
        await wait(600);

        unfocusAll();
        await wait(300);
    }

    /* ════════════════════════════════════════════════
       PHASE 3 — Scroll indicator + idle shuffle
       ════════════════════════════════════════════════ */
    document.getElementById('scroll-indicator').classList.add('visible');
    await wait(3000);
    idleShuffle();
}

function idleShuffle() {
    if (_allReelCtrls.length === 0) return;

    var count = 1 + Math.floor(Math.random() * Math.min(3, _allReelCtrls.length));
    var picked = [];
    while (picked.length < count) {
        var idx = Math.floor(Math.random() * _allReelCtrls.length);
        if (picked.indexOf(idx) === -1) picked.push(idx);
    }

    picked.forEach(function(ri, i) {
        setTimeout(function() { _allReelCtrls[ri].spin(); }, i * 150 + Math.floor(Math.random() * 150));
    });

    var delay = 1800 + Math.floor(Math.random() * 2500);
    setTimeout(idleShuffle, delay);
}


/* ══════════════════════════════════════════════════════════════
   ═══════════════════ INTERACTIVE DEMO ═══════════════════════
   ══════════════════════════════════════════════════════════════ */

var demoState = {
    wildcards: [],       // {name, values, color, reelEl}
    lines: [],
    connectorEls: [],
    prevOdo: 0,
    parentLine: null,
    colorIdx: 0
};

var demoContainer = document.getElementById('demo-lines');
var demoFormulaEl = document.getElementById('demo-formula');
var demoCountEl = document.getElementById('demo-count');
var demoLabelEl = document.getElementById('demo-label');
var popoverEl = document.getElementById('wc-popover');
var _activePopoverWc = null;

function nextDemoColor() {
    var c = DEMO_COLORS[demoState.colorIdx % DEMO_COLORS.length];
    demoState.colorIdx++;
    return c;
}

/* ── Build an interactive reel (pre-activated, clickable) ── */
function buildDemoReel(name, values) {
    var reel = document.createElement('span');
    reel.className = 'reel interactive';
    reel.setAttribute('data-wc', name);
    reel.setAttribute('data-testid', 'demo-reel-' + name);

    var label = document.createElement('span');
    label.className = 'reel-label float';
    label.textContent = name;
    reel.appendChild(label);

    var win = document.createElement('span');
    win.className = 'reel-window open';

    var track = document.createElement('span');
    track.className = 'reel-track visible';

    values.forEach(function(v) {
        var item = document.createElement('span');
        item.className = 'reel-item';
        item.textContent = v;
        track.appendChild(item);
    });

    win.appendChild(track);
    reel.appendChild(win);

    var maxLen = 0;
    values.forEach(function(v) { if (v.length > maxLen) maxLen = v.length; });
    reel.style.minWidth = Math.max(name.length + 1, maxLen + 1) + 'ch';

    reel._values = values;
    reel._name = name;
    reel._track = track;
    reel._label = label;
    reel._currentIdx = 0;

    reel.addEventListener('click', function(e) {
        e.stopPropagation();
        openPopover(reel);
    });

    return reel;
}

/* ── Build a demo line with text + reels ── */
function buildDemoLineEl(text, wildcards, isChild) {
    var line = document.createElement('div');
    line.className = 'editor-line' + (isChild ? ' editor-line--child visible' : '');

    var sorted = wildcards.slice().sort(function(a, b) { return a.pos - b.pos; });
    var cursor = 0;
    var reels = [];

    sorted.forEach(function(wc) {
        if (wc.pos > cursor) {
            line.appendChild(document.createTextNode(text.slice(cursor, wc.pos)));
        }

        var reel = buildDemoReel(wc.name, wc.values);
        reels.push({ name: wc.name, values: wc.values, reelEl: reel });
        line.appendChild(reel);
        cursor = wc.pos + wc.len;
    });

    if (cursor < text.length) {
        line.appendChild(document.createTextNode(text.slice(cursor)));
    }

    return { lineEl: line, reels: reels };
}

/* ── Initialize the demo with pre-filled prompt ── */
function initDemo() {
    // Parent: "A cabin in the forest, [season], [style]"
    var parentText = BASE + ', autumn, watercolor';
    var parentResult = buildDemoLineEl(parentText, [
        { pos: BASE.length + 2, len: 6, name: 'season', values: SEASONS.slice() },
        { pos: BASE.length + 10, len: 10, name: 'style', values: STYLES.slice() }
    ], false);
    demoContainer.appendChild(parentResult.lineEl);
    demoState.parentLine = parentResult.lineEl;
    demoState.lines.push(parentResult.lineEl);

    parentResult.reels.forEach(function(r) {
        demoState.wildcards.push({
            name: r.name,
            values: r.values.slice(),
            color: nextDemoColor(),
            reelEl: r.reelEl,
            _recalcFn: demoRecalc
        });
    });

    // Child: "└── with [detail] level of detail"
    var childText = 'with high level of detail';
    var childResult = buildDemoLineEl(childText, [
        { pos: 5, len: 4, name: 'detail', values: ['high', 'medium', 'sketch'] }
    ], true);

    var conn = document.createElement('span');
    conn.className = 'tree-connector';
    conn.textContent = '\u2514\u2500\u2500 ';
    demoState.connectorEls.push(conn);
    childResult.lineEl.insertBefore(conn, childResult.lineEl.firstChild);

    demoContainer.appendChild(childResult.lineEl);
    demoState.lines.push(childResult.lineEl);

    childResult.reels.forEach(function(r) {
        demoState.wildcards.push({
            name: r.name,
            values: r.values.slice(),
            color: nextDemoColor(),
            reelEl: r.reelEl,
            _recalcFn: demoRecalc
        });
    });

    demoRecalc();
}

/* ── Recalculate formula + odometer ── */
function demoRecalc() {
    demoFormulaEl.innerHTML = '';
    var total = 1;

    demoState.wildcards.forEach(function(wc, i) {
        if (wc.values.length === 0) return;

        if (demoFormulaEl.children.length > 0) {
            var x = document.createElement('span');
            x.className = 'formula-x visible';
            x.textContent = '\u00d7';
            demoFormulaEl.appendChild(x);
        }

        var term = document.createElement('span');
        term.className = 'formula-term visible';
        term.style.color = wc.color;
        term.innerHTML = wc.name + '<span class="formula-count">(' + wc.values.length + ')</span>';
        demoFormulaEl.appendChild(term);

        total *= wc.values.length;
    });

    var prev = demoState.prevOdo;
    demoState.prevOdo = total;
    rollOdometerTo(demoCountEl, total, prev);
    demoLabelEl.classList.add('visible');
}

/* ── Rebuild a reel's track after values change ── */
function rebuildDemoReel(wcData) {
    var reel = wcData.reelEl;
    var track = reel._track;

    track.innerHTML = '';
    wcData.values.forEach(function(v) {
        var item = document.createElement('span');
        item.className = 'reel-item';
        item.textContent = v;
        track.appendChild(item);
    });

    reel._values = wcData.values;
    reel._currentIdx = 0;

    var maxLen = 0;
    wcData.values.forEach(function(v) { if (v.length > maxLen) maxLen = v.length; });
    reel.style.minWidth = Math.max(wcData.name.length + 1, maxLen + 1) + 'ch';

    track.style.transition = 'none';
    track.style.transform = 'translateY(0)';
}

/* ══════════════════════════════════════════════════
   POPOVER — edit wildcard values
   ══════════════════════════════════════════════════ */
function openPopover(reelEl) {
    var wcData = reelEl._wcRef || demoState.wildcards.find(function(w) { return w.reelEl === reelEl; });
    if (!wcData) return;

    // Close previous
    if (_activePopoverWc && _activePopoverWc.reelEl) {
        _activePopoverWc.reelEl.classList.remove('popover-open');
    }

    _activePopoverWc = wcData;
    reelEl.classList.add('popover-open');

    // Position below the reel
    var rect = reelEl.getBoundingClientRect();
    popoverEl.style.display = 'block';
    popoverEl.style.left = rect.left + 'px';
    popoverEl.style.top = (rect.bottom + 8) + 'px';

    renderPopoverContent();
}

function closePopover() {
    if (_activePopoverWc && _activePopoverWc.reelEl) {
        _activePopoverWc.reelEl.classList.remove('popover-open');
    }
    popoverEl.style.display = 'none';
    _activePopoverWc = null;
}

function renderPopoverContent() {
    if (!_activePopoverWc) return;
    var wcData = _activePopoverWc;

    var nameEl = popoverEl.querySelector('.wc-popover-name');
    var pillsEl = popoverEl.querySelector('.wc-popover-pills');
    var inputEl = popoverEl.querySelector('.wc-popover-input');

    nameEl.textContent = wcData.name;
    pillsEl.innerHTML = '';

    wcData.values.forEach(function(v, i) {
        var pill = document.createElement('span');
        pill.className = 'wc-pill';
        pill.setAttribute('data-testid', 'wc-pill-' + i);

        var text = document.createTextNode(v + ' ');
        pill.appendChild(text);

        if (wcData.values.length > 1) {
            var rm = document.createElement('span');
            rm.className = 'wc-pill-remove';
            rm.textContent = '\u00d7';
            rm.setAttribute('data-idx', i);
            pill.appendChild(rm);
        }

        pillsEl.appendChild(pill);
    });

    inputEl.value = '';
    inputEl.focus();
}

// Pill remove handler (delegated)
popoverEl.querySelector('.wc-popover-pills').addEventListener('click', function(e) {
    var rm = e.target.closest('.wc-pill-remove');
    if (!rm || !_activePopoverWc) return;
    var idx = parseInt(rm.getAttribute('data-idx'));
    if (_activePopoverWc.values.length <= 1) return;
    _activePopoverWc.values.splice(idx, 1);
    rebuildDemoReel(_activePopoverWc);
    if (_activePopoverWc._recalcFn) _activePopoverWc._recalcFn(); else demoRecalc();
    renderPopoverContent();
});

// Input handler — Enter or comma to add values
popoverEl.querySelector('.wc-popover-input').addEventListener('keydown', function(e) {
    if (e.key !== 'Enter') return;
    e.preventDefault();
    if (!_activePopoverWc) return;

    var raw = this.value;
    var newVals = raw.split(',').map(function(s) { return s.trim(); }).filter(function(s) { return s.length > 0; });
    if (newVals.length === 0) return;

    newVals.forEach(function(v) {
        if (_activePopoverWc.values.indexOf(v) === -1) {
            _activePopoverWc.values.push(v);
        }
    });

    rebuildDemoReel(_activePopoverWc);
    if (_activePopoverWc._recalcFn) _activePopoverWc._recalcFn(); else demoRecalc();
    renderPopoverContent();
});

// Close popover on click outside
document.addEventListener('click', function(e) {
    if (!_activePopoverWc) return;
    if (popoverEl.contains(e.target)) return;
    if (e.target.closest('.reel.interactive')) return;
    closePopover();
});

/* ══════════════════════════════════════════════════
   ADD CHILD — new editable child line
   ══════════════════════════════════════════════════ */
document.getElementById('btn-add-child').addEventListener('click', function() {
    closePopover();

    // Update previous last connector └ → ├
    if (demoState.connectorEls.length > 0) {
        demoState.connectorEls[demoState.connectorEls.length - 1].textContent = '\u251C\u2500\u2500 ';
    }

    var childLine = document.createElement('div');
    childLine.className = 'editor-line editor-line--child visible';

    var conn = document.createElement('span');
    conn.className = 'tree-connector';
    conn.textContent = '\u2514\u2500\u2500 ';
    demoState.connectorEls.push(conn);
    childLine.appendChild(conn);

    var input = document.createElement('span');
    input.className = 'demo-child-input';
    input.contentEditable = 'true';
    input.setAttribute('data-placeholder', 'type text, use [brackets] for wildcards');
    input.setAttribute('data-testid', 'demo-child-input');
    childLine.appendChild(input);

    demoContainer.appendChild(childLine);
    demoState.lines.push(childLine);
    input.focus();

    var committed = false;
    function commit() {
        if (committed) return;
        var text = input.textContent.trim();
        if (!text) return;
        committed = true;
        commitInput(input, childLine);
    }

    input.addEventListener('keydown', function(e) {
        if (e.key === 'Enter') { e.preventDefault(); commit(); }
    });
    input.addEventListener('blur', function() {
        setTimeout(commit, 100);
    });
});

/* ══════════════════════════════════════════════════
   ADD WILDCARD — append to parent line
   ══════════════════════════════════════════════════ */
document.getElementById('btn-add-wildcard').addEventListener('click', function() {
    closePopover();

    var parentLine = demoState.parentLine;
    if (!parentLine) return;

    // Append ", " + editable span
    parentLine.appendChild(document.createTextNode(', '));

    var input = document.createElement('span');
    input.className = 'demo-child-input';
    input.contentEditable = 'true';
    input.setAttribute('data-placeholder', '[name]');
    input.setAttribute('data-testid', 'demo-wc-input');
    parentLine.appendChild(input);
    input.focus();

    var committed = false;
    function commit() {
        if (committed) return;
        var text = input.textContent.trim();
        if (!text) return;
        committed = true;
        commitInput(input, parentLine);
    }

    input.addEventListener('keydown', function(e) {
        if (e.key === 'Enter') { e.preventDefault(); commit(); }
    });
    input.addEventListener('blur', function() {
        setTimeout(commit, 100);
    });
});

/* ══════════════════════════════════════════════════
   COMMIT INPUT — parse [brackets], create reels
   ══════════════════════════════════════════════════ */
function commitInput(inputEl, lineEl) {
    var text = inputEl.textContent.trim();
    if (!text) return;

    // Parse [bracket] patterns
    var regex = /\[([^\]]+)\]/g;
    var match;
    var wildcards = [];

    while ((match = regex.exec(text)) !== null) {
        wildcards.push({ pos: match.index, len: match[0].length, name: match[1] });
    }

    // Replace input element with parsed content
    var parent = inputEl.parentNode;
    var frag = document.createDocumentFragment();

    if (wildcards.length === 0) {
        // No wildcards — just plain text
        frag.appendChild(document.createTextNode(text));
    } else {
        var cursor = 0;
        wildcards.forEach(function(wc) {
            if (wc.pos > cursor) {
                frag.appendChild(document.createTextNode(text.slice(cursor, wc.pos)));
            }

            var initValues = [wc.name];
            var reel = buildDemoReel(wc.name, initValues);
            frag.appendChild(reel);

            var wcData = {
                name: wc.name,
                values: initValues.slice(),
                color: nextDemoColor(),
                reelEl: reel,
                _recalcFn: demoRecalc
            };
            demoState.wildcards.push(wcData);

            cursor = wc.pos + wc.len;
        });

        if (cursor < text.length) {
            frag.appendChild(document.createTextNode(text.slice(cursor)));
        }
    }

    parent.replaceChild(frag, inputEl);
    demoRecalc();

    // Auto-open popover for first new wildcard
    if (wildcards.length > 0) {
        var firstNewReel = null;
        for (var i = demoState.wildcards.length - wildcards.length; i < demoState.wildcards.length; i++) {
            firstNewReel = demoState.wildcards[i].reelEl;
            break;
        }
        if (firstNewReel) {
            setTimeout(function() { openPopover(firstNewReel); }, 150);
        }
    }
}

/* ══════════════════════════════════════════════════
   SCROLL INDICATOR
   ══════════════════════════════════════════════════ */
document.getElementById('scroll-indicator').addEventListener('click', function() {
    document.getElementById('demo-section').scrollIntoView({ behavior: 'smooth' });
});

/* ══════════════════════════════════════════════════════════════
   ═══════════════════ QUILL EDITOR SECTION ═══════════════════
   ══════════════════════════════════════════════════════════════ */

/* ── DemoWildcardBlot — minimal inline embed ── */
var QEmbed = Quill.import('blots/embed');

class DemoWildcardBlot extends QEmbed {
    static blotName = 'wildcard';
    static tagName = 'span';
    static className = 'ql-wildcard-chip';

    static create(value) {
        var node = super.create();
        node.setAttribute('data-wildcard-name', value.name || '');
        node.setAttribute('contenteditable', 'false');

        // Floating label (matches view mode reel label)
        var labelSpan = document.createElement('span');
        labelSpan.className = 'ql-wc-label';
        labelSpan.textContent = value.name;
        node.appendChild(labelSpan);

        // Value display (shows first value or name as placeholder)
        var valueSpan = document.createElement('span');
        valueSpan.className = 'ql-wc-value';
        valueSpan.textContent = value.name;
        node.appendChild(valueSpan);

        return node;
    }

    static value(node) {
        return { name: node.getAttribute('data-wildcard-name') || '' };
    }
}

Quill.register(DemoWildcardBlot);

/* ── Quill section state ── */
var qState = {
    blocks: [],      // { id, isChild, lineEl, viewEl, editEl, quill, wildcards, _prevWildcards, _connector }
    prevOdo: 0,
    colorIdx: 0,
    persistentQuill: null,
    nextId: 0
};

var qBlocksEl = document.getElementById('quill-blocks');
var qFormulaEl = document.getElementById('quill-formula');
var qCountEl = document.getElementById('quill-count');

function nextQColor() {
    var c = DEMO_COLORS[qState.colorIdx % DEMO_COLORS.length];
    qState.colorIdx++;
    return c;
}

/* ── Serialize Quill delta to plain text with __name__ patterns ── */
function serializeQuill(quill) {
    var delta = quill.getContents();
    var text = '';
    delta.ops.forEach(function(op) {
        if (typeof op.insert === 'string') {
            text += op.insert;
        } else if (op.insert && op.insert.wildcard) {
            text += '__' + op.insert.wildcard.name + '__';
        }
    });
    return text.replace(/\n$/, '');
}

/* ── Parse __name__ patterns into wildcard positions ── */
function parseQWildcards(text) {
    var regex = /__([a-zA-Z](?:[a-zA-Z0-9_-]*[a-zA-Z0-9])?)__/g;
    var match;
    var wildcards = [];
    while ((match = regex.exec(text)) !== null) {
        wildcards.push({ pos: match.index, len: match[0].length, name: match[1] });
    }
    return wildcards;
}

/* ── Convert __name__ patterns in Quill to chip embeds (atomic Delta) ── */
var _qConverting = false;
var QDelta = Quill.import('delta');
function convertQWildcards(quill) {
    if (_qConverting) return false;
    var text = quill.getText();
    // Name must start with letter, end with alphanumeric (prevents _ eating into __ delimiter)
    var match = /__([a-zA-Z](?:[a-zA-Z0-9_-]*[a-zA-Z0-9])?)__/.exec(text);
    if (!match) return false;
    _qConverting = true;
    // Single atomic operation: retain up to match, delete the pattern, insert embed
    var delta = new QDelta().retain(match.index).delete(match[0].length).insert({ wildcard: { name: match[1] } });
    quill.updateContents(delta, 'silent');
    quill.setSelection(match.index + 1, 0, 'silent');
    _qConverting = false;
    return true;
}

/* ── Recalculate formula + odometer for Quill section ── */
function qRecalc() {
    qFormulaEl.innerHTML = '';
    var total = 1;
    var allWc = [];

    qState.blocks.forEach(function(block) {
        block.wildcards.forEach(function(wc) {
            if (wc.values.length === 0) return;
            allWc.push(wc);
        });
    });

    allWc.forEach(function(wc, i) {
        if (i > 0) {
            var x = document.createElement('span');
            x.className = 'formula-x visible';
            x.textContent = '\u00d7';
            qFormulaEl.appendChild(x);
        }

        var term = document.createElement('span');
        term.className = 'formula-term visible';
        term.style.color = wc.color;
        term.innerHTML = wc.name + '<span class="formula-count">(' + wc.values.length + ')</span>';
        qFormulaEl.appendChild(term);

        total *= wc.values.length;
    });

    var prev = qState.prevOdo;
    qState.prevOdo = total;
    rollOdometerTo(qCountEl, total, prev);
}

/* ── Update tree connectors for Quill blocks ── */
function updateQConnectors() {
    var childBlocks = qState.blocks.filter(function(b) { return b.isChild; });
    childBlocks.forEach(function(b, i) {
        var text = (i < childBlocks.length - 1) ? '\u251C\u2500\u2500 ' : '\u2514\u2500\u2500 ';
        if (b._connector) b._connector.textContent = text;
        if (b._editConnector) b._editConnector.textContent = text;
    });
}

/* ── Build view mode content for a block ── */
function buildBlockView(block) {
    var viewEl = block.viewEl;
    viewEl.innerHTML = '';

    // Tree connector for children
    if (block.isChild) {
        var conn = document.createElement('span');
        conn.className = 'tree-connector';
        conn.textContent = '\u2514\u2500\u2500 ';
        block._connector = conn;
        viewEl.appendChild(conn);
    }

    // Parse serialized text
    var serialized = serializeQuill(block.quill);
    var wcDefs = parseQWildcards(serialized);

    // Save previous wildcards for value retention
    var prevMap = {};
    if (block._prevWildcards) {
        block._prevWildcards.forEach(function(pw) { prevMap[pw.name] = pw; });
    }

    block.wildcards = [];

    if (wcDefs.length === 0) {
        // Plain text only
        viewEl.appendChild(document.createTextNode(serialized));
    } else {
        var cursor = 0;
        wcDefs.forEach(function(wc) {
            var before = serialized.slice(cursor, wc.pos);
            if (before) viewEl.appendChild(document.createTextNode(before));

            var prev = prevMap[wc.name];
            var values = prev ? prev.values.slice() : [wc.name];
            var color = prev ? prev.color : nextQColor();

            var reel = buildDemoReel(wc.name, values);

            var wcData = {
                name: wc.name,
                values: values,
                color: color,
                reelEl: reel,
                _recalcFn: qRecalc
            };

            // Store ref on reel so popover can find it
            reel._wcRef = wcData;

            viewEl.appendChild(reel);
            block.wildcards.push(wcData);

            cursor = wc.pos + wc.len;
        });

        var remaining = serialized.slice(cursor);
        if (remaining) viewEl.appendChild(document.createTextNode(remaining));
    }

    updateQConnectors();
    qRecalc();
}

/* ── Create a Quill-backed block ── */
function createQBlock(initialText, isChild, wildcardValues) {
    var id = qState.nextId++;

    var blockEl = document.createElement('div');
    blockEl.className = 'q-block' + (isChild ? ' q-block--child' : '');
    blockEl.setAttribute('data-block-id', id);

    // View mode
    var viewEl = document.createElement('div');
    viewEl.className = 'q-block-view editor-line' + (isChild ? ' editor-line--child visible' : '');
    blockEl.appendChild(viewEl);

    // Edit mode
    var editEl = document.createElement('div');
    editEl.className = 'q-block-edit';

    var editConn = null;
    if (isChild) {
        editConn = document.createElement('span');
        editConn.className = 'q-edit-connector';
        editConn.textContent = '\u2514\u2500\u2500 ';
        editEl.appendChild(editConn);
    }

    var quillContainer = document.createElement('div');
    quillContainer.className = 'q-quill-wrap';
    editEl.appendChild(quillContainer);
    blockEl.appendChild(editEl);

    // Create Quill instance
    var quill = new Quill(quillContainer, {
        theme: 'snow',
        modules: { toolbar: false },
        placeholder: ''
    });

    // Set initial content with wildcard embeds
    var wcParsed = parseQWildcards(initialText);
    if (wcParsed.length > 0) {
        var ops = [];
        var cursor = 0;
        wcParsed.forEach(function(wc) {
            if (wc.pos > cursor) {
                ops.push({ insert: initialText.slice(cursor, wc.pos) });
            }
            ops.push({ insert: { wildcard: { name: wc.name } } });
            cursor = wc.pos + wc.len;
        });
        var remaining = initialText.slice(cursor);
        if (remaining) ops.push({ insert: remaining });
        ops.push({ insert: '\n' });
        quill.setContents(ops, 'silent');
    } else {
        quill.setText(initialText, 'silent');
    }

    // Text-change: detect __name__ and convert to chip (user input only)
    quill.on('text-change', function(delta, oldDelta, source) {
        if (source !== 'user') return;
        convertQWildcards(quill);
    });

    var block = {
        id: id,
        isChild: isChild,
        lineEl: blockEl,
        viewEl: viewEl,
        editEl: editEl,
        quill: quill,
        wildcards: [],
        _prevWildcards: null,
        _connector: null,
        _editConnector: editConn
    };

    // Pre-seed wildcard values
    if (wildcardValues) {
        block._prevWildcards = Object.keys(wildcardValues).map(function(name) {
            return { name: name, values: wildcardValues[name].slice(), color: nextQColor() };
        });
    }

    // Click view → switch to edit
    viewEl.addEventListener('click', function(e) {
        if (e.target.closest('.reel.interactive')) return;
        switchToEdit(block);
    });

    qState.blocks.push(block);
    buildBlockView(block);

    return block;
}

/* ── Switch block to edit mode ── */
function switchToEdit(block) {
    // Close popover if open
    closePopover();
    block.lineEl.classList.add('editing');
    block.quill.focus();
    // Move cursor to end
    block.quill.setSelection(block.quill.getLength() - 1, 0);

    function finishEdit() {
        if (!block.lineEl.classList.contains('editing')) return;
        block._prevWildcards = block.wildcards.slice();
        block.lineEl.classList.remove('editing');
        buildBlockView(block);
    }

    var keyHandler = function(e) {
        if (e.key === 'Enter') {
            e.preventDefault();
            cleanup();
            finishEdit();
        } else if (e.key === 'Escape') {
            cleanup();
            finishEdit();
        }
    };

    var blurHandler = function() {
        setTimeout(function() {
            if (block.lineEl.classList.contains('editing')) {
                cleanup();
                finishEdit();
            }
        }, 200);
    };

    function cleanup() {
        block.quill.root.removeEventListener('keydown', keyHandler);
        block.quill.root.removeEventListener('blur', blurHandler);
    }

    block.quill.root.addEventListener('keydown', keyHandler);
    block.quill.root.addEventListener('blur', blurHandler);
}

/* ── Initialize Quill section with pre-filled data ── */
function initQuillSection() {
    // Parent: "A cabin in the forest, __season__, __style__"
    var parentBlock = createQBlock(
        BASE + ', __season__, __style__',
        false,
        { season: SEASONS.slice(), style: STYLES.slice() }
    );
    qBlocksEl.appendChild(parentBlock.lineEl);

    // Child: "with __detail__ level of detail"
    var childBlock = createQBlock(
        'with __detail__ level of detail',
        true,
        { detail: ['high', 'medium', 'sketch'] }
    );
    qBlocksEl.appendChild(childBlock.lineEl);

    // Persistent input (always-visible child input)
    var persistentContainer = document.getElementById('quill-persistent-editor');
    var persistentQuill = new Quill(persistentContainer, {
        theme: 'snow',
        modules: { toolbar: false },
        placeholder: 'type text, use __double_underscores__ for wildcards'
    });

    persistentQuill.on('text-change', function(delta, oldDelta, source) {
        if (source !== 'user') return;
        setTimeout(function() { convertQWildcards(persistentQuill); }, 0);
    });

    // Enter commits new child block
    persistentQuill.root.addEventListener('keydown', function(e) {
        if (e.key === 'Enter') {
            e.preventDefault();
            var serialized = serializeQuill(persistentQuill);
            if (!serialized.trim()) return;

            // Update previous last connector └ → ├
            updateQConnectors();

            var newBlock = createQBlock(serialized, true, null);
            qBlocksEl.appendChild(newBlock.lineEl);
            updateQConnectors();

            // Clear persistent input
            persistentQuill.setText('', 'silent');
        }
    });

    qState.persistentQuill = persistentQuill;
}

/* ══════════════════════════════════════════════════
   START
   ══════════════════════════════════════════════════ */
runAnimation();
initDemo();
initQuillSection();
</script>
</body>
</html>
