<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>PromptyUI — Try It</title>
<style>
:root {
    --bg-deep: #0a0a0a;
    --bg-surface: #161b22;
    --bg-elevated: #1c2128;
    --text-primary: #e6edf3;
    --text-secondary: #8b949e;
    --text-muted: #484f58;
    --accent-green: #3fb950;
    --accent-amber: #ff6b35;
    --accent-blue: #58a6ff;
    --accent-purple: #bc8cff;
    --reel-label: #e8943a;
    --reel-value: #529CCA;
    --reel-bg: rgba(82, 156, 202, 0.08);
    --font-mono: 'Courier New', Courier, monospace;
}

*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

body {
    font-family: var(--font-mono);
    background: var(--bg-deep);
    color: var(--text-primary);
    overflow-x: hidden;
    overflow-y: auto;
}

/* ── Editor lines ── */
.editor-line {
    font-size: clamp(0.85rem, 1.8vw, 1.1rem);
    line-height: 2.6em;
    white-space: nowrap;
    overflow: visible;
    color: var(--text-secondary);
    margin-top: 0.4em;
}

.editor-line--child {
    opacity: 0;
    transform: translateY(8px);
    transition: opacity 0.5s ease, transform 0.5s ease;
}

.editor-line--child.visible {
    opacity: 1;
    transform: translateY(0);
}

.tree-connector {
    color: var(--text-muted);
    user-select: none;
}

/* ── Inline reel ── */
.reel {
    display: inline-block;
    position: relative;
    vertical-align: middle;
    padding: 0 8px;
    border-radius: 4px;
    background: var(--reel-bg);
    overflow: visible;
    height: 1.6em;
    line-height: 1.6em;
}

.reel.interactive {
    cursor: pointer;
    transition: background 0.2s ease;
}

.reel.interactive:hover {
    background: rgba(82, 156, 202, 0.18);
}

.reel.interactive.popover-open {
    background: rgba(82, 156, 202, 0.22);
    outline: 1px solid rgba(82, 156, 202, 0.3);
}

.reel-badge {
    position: absolute;
    top: -0.55em;
    right: -0.65em;
    min-width: 1.3em;
    height: 1.3em;
    border-radius: 9999px;
    background: var(--bg-surface);
    color: var(--reel-label);
    font-size: 0.5em;
    font-weight: 700;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 0 0.3em;
    line-height: 1;
    pointer-events: none;
    z-index: 3;
}

.reel-label {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    text-align: center;
    color: var(--reel-label);
    font-size: inherit;
    line-height: 1.6em;
    white-space: nowrap;
    z-index: 2;
    pointer-events: none;
    transform-origin: center center;
    transform: translateY(0) scale(1);
    opacity: 1;
    transition: transform 0.6s cubic-bezier(0.4, 0, 0.2, 1),
                opacity 0.15s ease;
}

.reel-label.float {
    transform: translateY(-1.3em) scale(0.55);
    opacity: 1;
}

.reel-window {
    display: block;
    overflow: hidden;
    width: 100%;
    height: 0;
    transition: height 0.4s cubic-bezier(0.4, 0, 0.2, 1);
    -webkit-mask-image: linear-gradient(to bottom, transparent 0%, black 15%, black 85%, transparent 100%);
    mask-image: linear-gradient(to bottom, transparent 0%, black 15%, black 85%, transparent 100%);
}

.reel-window.open {
    height: 1.6em;
}

.reel-track {
    display: flex;
    flex-direction: column;
    align-items: center;
    opacity: 0;
    transition: transform 0.8s cubic-bezier(0.22, 1, 0.36, 1),
                opacity 0.4s ease;
}

.reel-track.visible {
    opacity: 1;
}

.reel-item {
    white-space: nowrap;
    font-size: inherit;
    color: var(--reel-value);
    line-height: 1.6em;
    height: 1.6em;
    display: flex;
    align-items: center;
    justify-content: center;
}

/* ── Formula ── */
.demo-formula {
    font-size: clamp(0.75rem, 1.4vw, 1rem);
    color: var(--text-muted);
    display: flex;
    align-items: center;
    gap: 0.5ch;
    flex-wrap: wrap;
    justify-content: center;
}

.formula-term {
    font-weight: 500;
}

.formula-count {
    opacity: 0.55;
}

.formula-x {
    color: var(--text-muted);
}

/* ── Big odometer count ── */
.demo-count {
    font-size: clamp(2rem, 5vw, 3.5rem);
    font-weight: 700;
    color: var(--accent-amber);
    display: flex;
    align-items: center;
    justify-content: center;
    line-height: 1;
}

.odo-wrap {
    display: inline-block;
    height: 1em;
    overflow: hidden;
    line-height: 1;
}

.odo-strip { display: block; }

.odo-d {
    display: block;
    height: 1em;
    line-height: 1;
    text-align: center;
}

.odo-comma { line-height: 1; }

.math-label {
    font-size: 0.8rem;
    color: var(--text-muted);
    letter-spacing: 0.12em;
    text-transform: uppercase;
    opacity: 0;
    transition: opacity 0.4s ease;
}

.math-label.visible {
    opacity: 1;
}

/* ── Value popover ── */
.wc-popover {
    position: fixed;
    z-index: 100;
    background: var(--bg-elevated);
    border: 1px solid rgba(72, 79, 88, 0.5);
    border-radius: 8px;
    padding: 0.8rem;
    min-width: 200px;
    max-width: 320px;
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
}

.wc-popover-name {
    font-size: 0.7rem;
    color: var(--reel-label);
    text-transform: uppercase;
    letter-spacing: 0.1em;
    margin-bottom: 0.5rem;
}

.wc-popover-pills {
    display: flex;
    flex-wrap: wrap;
    gap: 0.3rem;
    margin-bottom: 0.5rem;
}

.wc-pill {
    display: inline-flex;
    align-items: center;
    gap: 0.3em;
    font-size: 0.8rem;
    color: var(--reel-value);
    background: rgba(82, 156, 202, 0.1);
    border: 1px solid rgba(82, 156, 202, 0.2);
    border-radius: 3px;
    padding: 0.15em 0.4em;
}

.wc-pill-remove {
    cursor: pointer;
    color: var(--text-muted);
    font-size: 0.9em;
    line-height: 1;
    transition: color 0.15s;
}

.wc-pill-remove:hover {
    color: #f85149;
}

.wc-popover-input {
    width: 100%;
    font-family: var(--font-mono);
    font-size: 0.8rem;
    color: var(--text-primary);
    background: var(--bg-deep);
    border: 1px solid rgba(72, 79, 88, 0.4);
    border-radius: 4px;
    padding: 0.35em 0.5em;
    outline: none;
}

.wc-popover-input:focus {
    border-color: var(--reel-value);
}

.wc-popover-input::placeholder {
    color: var(--text-muted);
    font-size: 0.75rem;
}

/* ══════════════════════════════════════
   Quill Section
   ══════════════════════════════════════ */
.quill-section {
    min-height: 100vh;
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 6rem 2rem 4rem;
    border-top: 1px solid rgba(72, 79, 88, 0.2);
}

.quill-title {
    font-size: clamp(1.2rem, 3vw, 1.8rem);
    font-weight: 600;
    color: var(--text-primary);
    margin-bottom: 0.4rem;
}

.quill-subtitle {
    font-size: clamp(0.75rem, 1.4vw, 0.9rem);
    color: var(--text-muted);
    margin-bottom: 2.5rem;
}

.quill-editor-area {
    width: 100%;
    max-width: 700px;
    background: var(--bg-surface);
    border: 1px solid rgba(72, 79, 88, 0.3);
    border-radius: 8px;
    padding: 1.5rem 2rem;
}

.quill-blocks { min-height: 6em; overflow: visible; }

.q-block { position: relative; margin-bottom: 0.3em; overflow: visible; transition: margin-bottom 0.3s ease, opacity 0.3s ease; }
.q-block.editing { margin-bottom: 1.8em; }

.q-block-view {
    cursor: text;
    padding: 0.2em 0;
    border-radius: 4px;
    transition: background 0.15s;
}
.q-block-view:hover { background: rgba(72, 79, 88, 0.1); }
.q-block-edit { display: none; padding-bottom: 0; transition: padding-bottom 0.3s ease; }
.q-block.editing .q-block-view { display: none; }
.q-block.editing .q-block-edit {
    display: flex;
    align-items: baseline;
    position: relative;
    padding-bottom: 1.2em;
}
.q-block.editing .q-block-edit::after {
    content: '';
    position: absolute;
    bottom: 0;
    left: 0;
    right: 0;
    height: 1px;
    background: linear-gradient(to right, transparent, var(--reel-value), transparent);
    opacity: 0.4;
}
.q-block.editing .q-add-child-hint {
    position: absolute;
    bottom: -0.55em;
    left: 50%;
    transform: translateX(-50%);
    font-size: 9px;
    color: var(--text-secondary);
    background: var(--bg-surface);
    padding: 0 0.4em;
    white-space: nowrap;
    cursor: pointer;
    z-index: 4;
    letter-spacing: 0.02em;
    transition: color 0.15s;
    line-height: 1.5;
}
.q-block.editing .q-add-child-hint:hover {
    color: var(--reel-value);
}
.q-block.editing .q-add-child-hint kbd {
    font-family: var(--font-mono);
    font-size: 8px;
    color: var(--text-secondary);
    background: var(--bg-elevated);
    border: 1px solid var(--text-muted);
    border-bottom: 2px solid var(--text-muted);
    border-radius: 2px;
    padding: 0 0.2em;
    margin: 0 0.05em;
    display: inline-block;
    vertical-align: middle;
    line-height: 1.3;
    box-shadow: 0 1px 0 rgba(255,255,255,0.04), inset 0 1px 0 rgba(255,255,255,0.03);
}
.q-edit-connector {
    color: var(--text-muted);
    user-select: none;
    white-space: nowrap;
    line-height: 2.6em;
    flex-shrink: 0;
    margin-right: 0.5ch;
}

.q-quill-wrap { flex: 1; min-width: 0; }

.q-block-edit .ql-container.ql-snow {
    border: none;
    font-family: var(--font-mono);
    font-size: clamp(0.85rem, 1.8vw, 1.1rem);
    background: transparent;
    overflow: visible;
}
.q-block-edit .ql-editor {
    color: var(--text-secondary);
    padding: 0.2em 0;
    min-height: auto;
    line-height: 2.6em;
    caret-color: var(--accent-amber);
    overflow: visible;
    outline: none;
}
.q-block-edit .ql-editor.ql-blank::before { color: var(--text-muted); font-style: normal; }

.q-persistent-input {
    margin-top: 0.5em;
    padding-top: 0.5em;
    border-top: 1px dashed rgba(72, 79, 88, 0.3);
}
.q-persistent-input .ql-container.ql-snow {
    border: 1px dashed rgba(72, 79, 88, 0.4);
    border-radius: 4px;
    font-family: var(--font-mono);
    font-size: clamp(0.85rem, 1.8vw, 1.1rem);
    background: transparent;
    overflow: visible;
}
.q-persistent-input .ql-editor {
    color: var(--text-primary);
    padding: 0.4em 0.6em;
    min-height: 2em;
    line-height: 2em;
    caret-color: var(--accent-amber);
    overflow: visible;
}
.q-persistent-input .ql-editor.ql-blank::before { color: var(--text-muted); font-style: normal; }

.ql-wildcard-chip {
    display: inline-block;
    position: relative;
    vertical-align: middle;
    padding: 0 8px;
    border-radius: 4px;
    background: var(--reel-bg);
    cursor: pointer;
    height: 1.6em;
    line-height: 1.6em;
    overflow: visible;
    transition: background 0.2s ease;
}
/* Quill Embed wraps content in an inline span — make it layout-transparent */
.ql-wildcard-chip > span:not([class]) {
    display: contents;
}
.ql-wildcard-chip:hover {
    background: rgba(82, 156, 202, 0.18);
}
.ql-wildcard-chip.popover-open {
    background: rgba(82, 156, 202, 0.22);
    outline: 1px solid rgba(82, 156, 202, 0.3);
}
.ql-wc-label {
    position: absolute;
    top: 0; left: 0; right: 0;
    text-align: center;
    color: var(--reel-label);
    font-family: var(--font-mono);
    font-size: inherit;
    line-height: 1.6em;
    white-space: nowrap;
    pointer-events: none;
    transform-origin: center center;
    transform: translateY(0) scale(1);
    opacity: 1;
    transition: transform 0.6s cubic-bezier(0.4, 0, 0.2, 1),
                opacity 0.15s ease;
    z-index: 2;
}
.ql-wc-label.float {
    transform: translateY(-1.3em) scale(0.55);
    opacity: 1;
}
.ql-wc-window {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    display: block;
    overflow: hidden;
    height: 0;
    transition: height 0.4s cubic-bezier(0.4, 0, 0.2, 1);
    -webkit-mask-image: linear-gradient(to bottom, transparent 0%, black 15%, black 85%, transparent 100%);
    mask-image: linear-gradient(to bottom, transparent 0%, black 15%, black 85%, transparent 100%);
}
.ql-wc-window.open {
    height: 1.6em;
}
.ql-wc-track {
    display: flex;
    flex-direction: column;
    align-items: center;
    opacity: 0;
    transition: transform 0.8s cubic-bezier(0.22, 1, 0.36, 1),
                opacity 0.4s ease;
}
.ql-wc-track.visible {
    opacity: 1;
}
.ql-wc-item {
    white-space: nowrap;
    font-size: inherit;
    color: var(--reel-value);
    line-height: 1.6em;
    height: 1.6em;
    display: flex;
    align-items: center;
    justify-content: center;
}
.ql-wc-item.placeholder {
    color: var(--text-muted);
    font-size: 1.1em;
    font-style: normal;
    font-weight: 300;
}
.ql-wc-badge {
    position: absolute;
    top: -0.55em;
    right: -0.65em;
    min-width: 1.3em;
    height: 1.3em;
    border-radius: 9999px;
    background: var(--bg-surface);
    color: var(--reel-label);
    font-size: 0.5em;
    font-weight: 700;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 0 0.3em;
    line-height: 1;
    pointer-events: none;
    z-index: 10;
}

.quill-formula-area {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 0.4rem;
    margin-top: 2.5rem;
}
.quill-count { font-size: clamp(2rem, 5vw, 3.5rem); }

/* ── Responsive ── */
@media (max-width: 768px) {
    /* depth-based padding set inline via JS */
    .quill-section { padding: 4rem 1rem 3rem; }
    .quill-editor-area { padding: 1rem; }
}
</style>
</head>
<body>

<!-- Value popover (fixed positioned) -->
<div class="wc-popover" id="wc-popover" style="display: none;" data-testid="wc-popover">
    <div class="wc-popover-name"></div>
    <div class="wc-popover-pills"></div>
    <input class="wc-popover-input" type="text" placeholder="add values, comma separated" data-testid="wc-popover-input">
</div>

<!-- ═══════════════════════════════════════════
     SECTION 2: Quill Editor
     ═══════════════════════════════════════════ -->
<section class="quill-section" id="quill-section">
    <h2 class="quill-title">Quill Editor</h2>
    <p class="quill-subtitle">Click a block to edit &middot; Type __name__ for wildcards</p>

    <div class="quill-editor-area" data-testid="quill-editor-area">
        <div class="quill-blocks" id="quill-blocks"></div>
        <div class="q-persistent-input">
            <div id="quill-persistent-editor"></div>
        </div>
    </div>

    <div class="quill-formula-area">
        <div class="demo-formula" id="quill-formula"></div>
        <div class="demo-count quill-count" id="quill-count" data-testid="quill-count"></div>
        <div class="math-label visible" id="quill-label">compositions</div>
    </div>
</section>

<script src="/vendor/quill/quill.js"></script>
<script>
/* ══════════════════════════════════════════════════
   DATA
   ══════════════════════════════════════════════════ */
var SEASONS = ['autumn', 'winter', 'spring', 'summer'];
var STYLES = ['watercolor', 'oil', 'digital', 'pencil'];
var BASE = 'A cabin in the forest';
var DEMO_COLORS = ['#ff6b35', '#58a6ff', '#3fb950', '#bc8cff', '#ff6b35', '#58a6ff', '#3fb950'];

/* ══════════════════════════════════════════════════
   ODOMETER
   ══════════════════════════════════════════════════ */
function rollOdometerTo(containerEl, num, prevNum) {
    var newFormatted = num.toLocaleString();
    var newRaw = num.toString().split('').map(Number);
    var oldRaw = prevNum.toString().split('').map(Number);

    while (oldRaw.length < newRaw.length) oldRaw.unshift(0);
    while (newRaw.length < oldRaw.length) newRaw.unshift(0);

    containerEl.innerHTML = '';
    var rawIdx = 0;
    var totalDigits = newRaw.length;

    newFormatted.split('').forEach(function(ch) {
        if (ch === ',') {
            var comma = document.createElement('span');
            comma.className = 'odo-comma';
            comma.textContent = ',';
            containerEl.appendChild(comma);
            return;
        }

        var target = parseInt(ch);
        var from = oldRaw[rawIdx] || 0;
        var staggerDelay = (totalDigits - 1 - rawIdx) * 80 + 20;
        rawIdx++;

        var stripEnd = 9;
        if (target < from) {
            stripEnd = 10 + target;
        }

        var wrap = document.createElement('span');
        wrap.className = 'odo-wrap';
        var strip = document.createElement('span');
        strip.className = 'odo-strip';

        for (var n = 0; n <= stripEnd; n++) {
            var d = document.createElement('span');
            d.className = 'odo-d';
            d.textContent = n % 10;
            strip.appendChild(d);
        }

        strip.style.transform = 'translateY(' + (-from) + 'em)';
        wrap.appendChild(strip);
        containerEl.appendChild(wrap);

        (function(s, t, se, dl) {
            var animTarget = (t < from) ? se : t;
            setTimeout(function() {
                s.style.transition = 'transform 1s cubic-bezier(0.22, 1, 0.36, 1)';
                s.style.transform = 'translateY(' + (-animTarget) + 'em)';
            }, dl);
        })(strip, target, stripEnd, staggerDelay);
    });
}

/* ══════════════════════════════════════════════════
   SHARED STATE
   ══════════════════════════════════════════════════ */

var popoverEl = document.getElementById('wc-popover');
var _activePopoverWc = null;

/* ── Build an interactive reel (pre-activated, clickable) ── */
function buildDemoReel(name, values) {
    var reel = document.createElement('span');
    reel.className = 'reel interactive';
    reel.setAttribute('data-wc', name);
    reel.setAttribute('data-testid', 'demo-reel-' + name);

    var label = document.createElement('span');
    label.className = 'reel-label float';
    label.textContent = name;
    reel.appendChild(label);

    var win = document.createElement('span');
    win.className = 'reel-window open';

    var track = document.createElement('span');
    track.className = 'reel-track visible';

    values.forEach(function(v) {
        var item = document.createElement('span');
        item.className = 'reel-item';
        item.textContent = v;
        track.appendChild(item);
    });

    win.appendChild(track);
    reel.appendChild(win);

    var maxLen = 0;
    values.forEach(function(v) { if (v.length > maxLen) maxLen = v.length; });
    reel.style.minWidth = Math.max(name.length + 1, maxLen + 1) + 'ch';

    if (values.length > 1) {
        var badge = document.createElement('span');
        badge.className = 'reel-badge';
        badge.textContent = '+' + values.length;
        reel._badge = badge;
        reel.appendChild(badge);
    }

    reel._values = values;
    reel._name = name;
    reel._track = track;
    reel._label = label;
    reel._currentIdx = 0;

    reel.addEventListener('click', function(e) {
        e.stopPropagation();
        openPopover(reel);
    });

    return reel;
}

/* ── Rebuild a reel's track after values change ── */
function rebuildDemoReel(wcData) {
    var reel = wcData.reelEl;
    var track = reel._track;

    track.innerHTML = '';
    wcData.values.forEach(function(v) {
        var item = document.createElement('span');
        item.className = 'reel-item';
        item.textContent = v;
        track.appendChild(item);
    });

    reel._values = wcData.values;
    reel._currentIdx = 0;

    var maxLen = 0;
    wcData.values.forEach(function(v) { if (v.length > maxLen) maxLen = v.length; });
    reel.style.minWidth = Math.max(wcData.name.length + 1, maxLen + 1) + 'ch';

    // Update badge count
    if (reel._badge) {
        if (wcData.values.length > 1) {
            reel._badge.textContent = '+' + wcData.values.length;
        } else {
            reel._badge.remove();
            reel._badge = null;
        }
    } else if (wcData.values.length > 1) {
        var badge = document.createElement('span');
        badge.className = 'reel-badge';
        badge.textContent = '+' + wcData.values.length;
        reel._badge = badge;
        reel.appendChild(badge);
    }

    track.style.transition = 'none';
    track.style.transform = 'translateY(0)';
}

/* ══════════════════════════════════════════════════
   POPOVER — edit wildcard values
   ══════════════════════════════════════════════════ */
var _popoverIsChip = false; // true when popover opened from an edit-mode chip
var _popoverFromClick = false; // true when popover opened by explicit click (not cursor-adjacent)

function openPopover(reelEl, fromClick) {
    var wcData = reelEl._wcRef;
    if (!wcData) return;

    if (_activePopoverWc && _activePopoverWc.reelEl) {
        _activePopoverWc.reelEl.classList.remove('popover-open');
    }

    _activePopoverWc = wcData;
    _popoverIsChip = reelEl.classList.contains('ql-wildcard-chip');
    _popoverFromClick = !!fromClick;
    reelEl.classList.add('popover-open');

    var rect = reelEl.getBoundingClientRect();
    popoverEl.style.display = 'block';

    // Measure popover width, then clamp to viewport edges (12px margin)
    var popW = popoverEl.offsetWidth;
    var left = Math.max(12, Math.min(rect.left, window.innerWidth - popW - 12));
    popoverEl.style.left = left + 'px';
    popoverEl.style.top = (rect.bottom + 8) + 'px';

    renderPopoverContent();
}

function closePopover() {
    if (_activePopoverWc && _activePopoverWc.reelEl) {
        _activePopoverWc.reelEl.classList.remove('popover-open');
    }
    popoverEl.style.display = 'none';
    _activePopoverWc = null;
}

function renderPopoverContent() {
    if (!_activePopoverWc) return;
    var wcData = _activePopoverWc;

    var nameEl = popoverEl.querySelector('.wc-popover-name');
    var pillsEl = popoverEl.querySelector('.wc-popover-pills');
    var inputEl = popoverEl.querySelector('.wc-popover-input');

    nameEl.textContent = wcData.name;
    pillsEl.innerHTML = '';

    wcData.values.forEach(function(v, i) {
        var pill = document.createElement('span');
        pill.className = 'wc-pill';
        pill.setAttribute('data-testid', 'wc-pill-' + i);

        var text = document.createTextNode(v + ' ');
        pill.appendChild(text);

        if (wcData.values.length > 1) {
            var rm = document.createElement('span');
            rm.className = 'wc-pill-remove';
            rm.textContent = '\u00d7';
            rm.setAttribute('data-idx', i);
            pill.appendChild(rm);
        }

        pillsEl.appendChild(pill);
    });

    inputEl.value = '';
    if (_popoverIsChip && !_popoverFromClick) {
        // Cursor-adjacent auto-open: don't steal focus from editor
        inputEl.placeholder = 'Press Tab to focus';
        inputEl.blur();
    } else {
        // Explicit click (chip or reel): autofocus the input
        inputEl.placeholder = 'add values, comma separated';
        inputEl.focus();
    }
}

// Pill remove handler (delegated)
popoverEl.querySelector('.wc-popover-pills').addEventListener('click', function(e) {
    var rm = e.target.closest('.wc-pill-remove');
    if (!rm || !_activePopoverWc) return;
    var idx = parseInt(rm.getAttribute('data-idx'));
    if (_activePopoverWc.values.length <= 1) return;
    _activePopoverWc.values.splice(idx, 1);
    // rebuildDemoReel only works on reel elements, not chip elements
    if (!_activePopoverWc.reelEl.classList.contains('ql-wildcard-chip')) {
        rebuildDemoReel(_activePopoverWc);
    }
    if (_activePopoverWc._recalcFn) _activePopoverWc._recalcFn(); else qRecalc();
    renderPopoverContent();
});

// Input handler — Enter to add values
popoverEl.querySelector('.wc-popover-input').addEventListener('keydown', function(e) {
    if (e.key !== 'Enter') return;
    e.preventDefault();
    if (!_activePopoverWc) return;

    var raw = this.value;
    var newVals = raw.split(',').map(function(s) { return s.trim(); }).filter(function(s) { return s.length > 0; });
    if (newVals.length === 0) return;

    newVals.forEach(function(v) {
        if (_activePopoverWc.values.indexOf(v) === -1) {
            _activePopoverWc.values.push(v);
        }
    });

    if (!_activePopoverWc.reelEl.classList.contains('ql-wildcard-chip')) {
        rebuildDemoReel(_activePopoverWc);
    }
    if (_activePopoverWc._recalcFn) _activePopoverWc._recalcFn(); else qRecalc();
    renderPopoverContent();
});

// Placeholder swap on focus/blur + Tab redirect
(function() {
    var inp = popoverEl.querySelector('.wc-popover-input');
    inp.addEventListener('focus', function() {
        this.placeholder = 'add values, comma separated';
    });
    inp.addEventListener('blur', function() {
        this.placeholder = 'Press Tab to focus';
    });
    // When popover is open and Tab is pressed, focus the popover input
    document.addEventListener('keydown', function(e) {
        if (e.key !== 'Tab' || !_activePopoverWc) return;
        if (document.activeElement === inp) return; // already focused
        e.preventDefault();
        inp.focus();
    });
})();

// Close popover on click outside
document.addEventListener('click', function(e) {
    if (!_activePopoverWc) return;
    if (popoverEl.contains(e.target)) return;
    if (e.target.closest('.reel.interactive')) return;
    if (e.target.closest('.ql-wildcard-chip')) return;
    closePopover();
});

/* ══════════════════════════════════════════════════════════════
   QUILL EDITOR SECTION
   ══════════════════════════════════════════════════════════════ */

/* ── DemoWildcardBlot — minimal inline embed ── */
var QEmbed = Quill.import('blots/embed');

class DemoWildcardBlot extends QEmbed {
    static blotName = 'wildcard';
    static tagName = 'span';
    static className = 'ql-wildcard-chip';

    static create(value) {
        var node = super.create();
        var name = value.name || '';
        node.setAttribute('data-wildcard-name', name);
        node.setAttribute('contenteditable', 'false');

        // Label — centered (closed) or floated (open)
        var label = document.createElement('span');
        label.className = 'ql-wc-label';
        label.textContent = name;
        node.appendChild(label);

        // Value window — height:0 (closed), .open shows value
        var win = document.createElement('span');
        win.className = 'ql-wc-window';
        var track = document.createElement('span');
        track.className = 'ql-wc-track';
        win.appendChild(track);
        node.appendChild(win);

        // Stash refs for hydration
        node._label = label;
        node._window = win;
        node._track = track;
        node._badge = null;
        node._wcName = name;

        // Click → open popover with autofocus
        node.addEventListener('click', function(e) {
            e.stopPropagation();
            openChipPopover(node, true);
        });

        // Hydrate from registry on next frame (DOM must be attached first)
        requestAnimationFrame(function() { hydrateChip(node); });

        return node;
    }

    static value(node) {
        return { name: node.getAttribute('data-wildcard-name') || '' };
    }
}

Quill.register(DemoWildcardBlot);

/* ── Chip helpers — hydrate, update, popover ── */

function hydrateChip(chipNode) {
    if (!chipNode.isConnected) return;
    var name = chipNode._wcName;
    var reg = qState.chipRegistry[name];
    if (reg) {
        if (reg.chipEls.indexOf(chipNode) === -1) reg.chipEls.push(chipNode);
    }
    var values = reg ? reg.values : [];
    updateChipAppearance(chipNode, values);
}

function updateChipAppearance(chipNode, values) {
    var name = chipNode._wcName;
    var reg = qState.chipRegistry[name];
    var isEmpty = !values || values.length === 0;

    // Clean disconnected chip elements
    if (reg) {
        reg.chipEls = reg.chipEls.filter(function(el) { return el.isConnected; });
    }

    // Float label
    chipNode._label.classList.add('float');

    // Rebuild track items
    var track = chipNode._track;
    track.innerHTML = '';

    if (isEmpty) {
        var placeholder = document.createElement('span');
        placeholder.className = 'ql-wc-item placeholder';
        placeholder.textContent = '+';
        track.appendChild(placeholder);
    } else {
        values.forEach(function(v) {
            var item = document.createElement('span');
            item.className = 'ql-wc-item';
            item.textContent = v;
            track.appendChild(item);
        });
    }
    track.classList.add('visible');

    // Open window
    chipNode._window.classList.add('open');

    // Compute min-width
    var maxLen = isEmpty ? 1 : 0;
    if (!isEmpty) {
        values.forEach(function(v) { if (v.length > maxLen) maxLen = v.length; });
    }
    chipNode.style.minWidth = Math.max(name.length + 1, maxLen + 1) + 'ch';

    // Badge
    if (chipNode._badge) {
        if (!isEmpty && values.length > 1) {
            chipNode._badge.textContent = '+' + values.length;
        } else {
            chipNode._badge.remove();
            chipNode._badge = null;
        }
    } else if (!isEmpty && values.length > 1) {
        var badge = document.createElement('span');
        badge.className = 'ql-wc-badge';
        badge.textContent = '+' + values.length;
        chipNode._badge = badge;
        chipNode.appendChild(badge);
    }
}

function openChipPopover(chipNode, fromClick) {
    var name = chipNode._wcName;

    // Ensure registry entry
    if (!qState.chipRegistry[name]) {
        qState.chipRegistry[name] = { values: [], color: nextQColor(), chipEls: [] };
    }
    var reg = qState.chipRegistry[name];
    if (reg.chipEls.indexOf(chipNode) === -1) reg.chipEls.push(chipNode);

    // Build a wcData-compatible object the popover can work with
    var wcData = {
        name: name,
        values: reg.values,
        color: reg.color,
        reelEl: chipNode,
        _recalcFn: function() {
            // Update all chip elements for this wildcard
            reg.chipEls = reg.chipEls.filter(function(el) { return el.isConnected; });
            reg.chipEls.forEach(function(el) { updateChipAppearance(el, reg.values); });
            // Sync into blocks so qRecalc formula is correct
            syncRegistryToBlocks();
            qRecalc();
        }
    };
    chipNode._wcRef = wcData;

    openPopover(chipNode, fromClick);
}

function syncRegistryToBlocks() {
    qState.blocks.forEach(function(block) {
        block.wildcards.forEach(function(wc) {
            var reg = qState.chipRegistry[wc.name];
            if (reg) {
                wc.values = reg.values;
                wc.color = reg.color;
            }
        });
    });
}

/* ── Quill section state ── */
var qState = {
    blocks: [],
    prevOdo: 0,
    colorIdx: 0,
    persistentQuill: null,
    nextId: 0,
    chipRegistry: {},
    _addingChild: false
};

var qBlocksEl = document.getElementById('quill-blocks');
var qFormulaEl = document.getElementById('quill-formula');
var qCountEl = document.getElementById('quill-count');
var QDelta = Quill.import('delta');

function nextQColor() {
    var c = DEMO_COLORS[qState.colorIdx % DEMO_COLORS.length];
    qState.colorIdx++;
    return c;
}

/* ── Serialize Quill delta to plain text with __name__ patterns ── */
function serializeQuill(quill) {
    var delta = quill.getContents();
    var text = '';
    delta.ops.forEach(function(op) {
        if (typeof op.insert === 'string') {
            text += op.insert;
        } else if (op.insert && op.insert.wildcard) {
            text += '__' + op.insert.wildcard.name + '__';
        }
    });
    return text.replace(/\n$/, '');
}

/* ── Parse __name__ patterns into wildcard positions ── */
function parseQWildcards(text) {
    var regex = /__([a-zA-Z](?:[a-zA-Z0-9_-]*[a-zA-Z0-9])?)__/g;
    var match;
    var wildcards = [];
    while ((match = regex.exec(text)) !== null) {
        wildcards.push({ pos: match.index, len: match[0].length, name: match[1] });
    }
    return wildcards;
}

/* ── Convert __name__ patterns to chip embeds — FIXED: uses getContents() + posMap ──
 *
 * Bug fixed: the original used quill.getText() which silently skips embed blots,
 * so match.index was offset by N (number of embeds before the pattern). This caused
 * the delta to delete the wrong range, leaving residual __ text after the chip.
 *
 * Fix: build a text→doc position map from getContents() so each character index in
 * searchText maps to the correct document position regardless of preceding embeds.
 */
function convertQWildcards(quill) {
    var contents = quill.getContents();
    var searchText = '';
    var docPos = 0;
    var posMap = []; // posMap[textCharIdx] = documentIdx

    contents.ops.forEach(function(op) {
        if (typeof op.insert === 'string') {
            for (var i = 0; i < op.insert.length; i++) {
                posMap.push(docPos + i);
            }
            searchText += op.insert;
            docPos += op.insert.length;
        } else {
            // Embed: 1 doc position, contributes 0 chars to searchText
            docPos += 1;
        }
    });
    posMap.push(docPos); // sentinel

    var match = /__([a-zA-Z](?:[a-zA-Z0-9_-]*[a-zA-Z0-9])?)__/.exec(searchText);
    if (!match) return false;

    var docMatchStart = posMap[match.index];
    var docMatchEnd = posMap[match.index + match[0].length];

    var delta = new QDelta()
        .retain(docMatchStart)
        .delete(docMatchEnd - docMatchStart)
        .insert({ wildcard: { name: match[1] } });

    quill.updateContents(delta, 'silent');

    // If the new chip is now the last element before \n, add ZWSP so the
    // browser has a real text node to anchor the caret (avoids top-right bug)
    if (docMatchStart + 1 === quill.getLength() - 1) {
        quill.updateContents(new QDelta().retain(docMatchStart + 1).insert('\u200B'), 'silent');
    }

    quill.setSelection(docMatchStart + 1, 0, 'silent');

    // Auto-open popover for newly typed chip (if it has no values yet)
    var newName = match[1];
    requestAnimationFrame(function() {
        var chip = quill.root.querySelector('.ql-wildcard-chip[data-wildcard-name="' + newName + '"]');
        if (chip && (!qState.chipRegistry[newName] || qState.chipRegistry[newName].values.length === 0)) {
            openChipPopover(chip);
        }
    });

    return true;
}

/* ── Recalculate formula + odometer for Quill section ── */
function qRecalc() {
    qFormulaEl.innerHTML = '';
    var total = 1;
    var terms = []; // { label, count, color }

    // ── Count total leaves across all root subtrees ──
    // A "leaf" is a terminal block (no children). Multiple roots are additive:
    // root1(2 leaves) + root2(1 leaf) = 3 total leaves.
    // Children under a parent create separate text variations (parent+child1, parent+child2).
    var roots = qState.blocks.filter(function(b) { return b.depth === 0; });
    var totalLeaves = 0;
    roots.forEach(function(root) {
        totalLeaves += countLeaves(root);
    });
    if (totalLeaves > 1) {
        terms.push({ label: 'lines', count: totalLeaves, color: 'var(--text-secondary)' });
    }

    // ── Collect unique wildcards across all blocks ──
    var seen = {};
    qState.blocks.forEach(function(block) {
        block.wildcards.forEach(function(wc) {
            if (wc.values.length === 0) return;
            if (seen[wc.name]) return; // deduplicate same wildcard across blocks
            seen[wc.name] = true;
            terms.push({ label: wc.name, count: wc.values.length, color: wc.color });
        });
    });

    // ── Build formula display ──
    terms.forEach(function(t, i) {
        if (i > 0) {
            var x = document.createElement('span');
            x.className = 'formula-x';
            x.textContent = '\u00d7';
            qFormulaEl.appendChild(x);
        }
        var term = document.createElement('span');
        term.className = 'formula-term';
        term.style.color = t.color;
        term.innerHTML = t.label + '<span class="formula-count">(' + t.count + ')</span>';
        qFormulaEl.appendChild(term);
        total *= t.count;
    });

    var prev = qState.prevOdo;
    qState.prevOdo = total;
    rollOdometerTo(qCountEl, total, prev);
}

/* ── Count leaf nodes in a block's subtree ── */
function countLeaves(block) {
    var children = getChildrenOf(block);
    if (children.length === 0) return 1; // terminal block = 1 leaf
    var total = 0;
    children.forEach(function(child) {
        total += countLeaves(child);
    });
    return total;
}

/* ── Update tree connectors for Quill blocks ── */
function updateQConnectors() {
    // For each block, find its direct children and set connectors
    for (var i = 0; i < qState.blocks.length; i++) {
        var parent = qState.blocks[i];
        var directChildren = getChildrenOf(parent);
        directChildren.forEach(function(b, ci) {
            var text = (ci < directChildren.length - 1) ? '\u251C\u2500\u2500 ' : '\u2514\u2500\u2500 ';
            if (b._connector) b._connector.textContent = text;
            if (b._editConnector) b._editConnector.textContent = text;
        });
    }
}

/* ── Build view mode content for a block ── */
function buildBlockView(block) {
    var viewEl = block.viewEl;
    viewEl.innerHTML = '';

    // Set depth-based indentation on view
    if (block.depth > 0) {
        viewEl.style.paddingLeft = (block.depth * 2) + 'ch';
        var conn = document.createElement('span');
        conn.className = 'tree-connector';
        conn.textContent = '\u2514\u2500\u2500 ';
        block._connector = conn;
        viewEl.appendChild(conn);
    } else {
        viewEl.style.paddingLeft = '';
    }

    var serialized = serializeQuill(block.quill);
    var wcDefs = parseQWildcards(serialized);

    var prevMap = {};
    if (block._prevWildcards) {
        block._prevWildcards.forEach(function(pw) { prevMap[pw.name] = pw; });
    }

    block.wildcards = [];

    if (wcDefs.length === 0) {
        viewEl.appendChild(document.createTextNode(serialized));
    } else {
        var cursor = 0;
        wcDefs.forEach(function(wc) {
            var before = serialized.slice(cursor, wc.pos);
            if (before) viewEl.appendChild(document.createTextNode(before));

            var prev = prevMap[wc.name];
            var reg = qState.chipRegistry[wc.name];
            var values = prev ? prev.values.slice() : (reg ? reg.values.slice() : [wc.name]);
            var color = prev ? prev.color : (reg ? reg.color : nextQColor());

            var reel = buildDemoReel(wc.name, values);
            var wcData = {
                name: wc.name,
                values: values,
                color: color,
                reelEl: reel,
                _recalcFn: qRecalc
            };
            reel._wcRef = wcData;
            viewEl.appendChild(reel);
            block.wildcards.push(wcData);

            // Sync registry so chips in edit mode stay current
            if (!qState.chipRegistry[wc.name]) {
                qState.chipRegistry[wc.name] = { values: values, color: color, chipEls: [] };
            } else {
                qState.chipRegistry[wc.name].values = values;
                qState.chipRegistry[wc.name].color = color;
            }

            cursor = wc.pos + wc.len;
        });

        var remaining = serialized.slice(cursor);
        if (remaining) viewEl.appendChild(document.createTextNode(remaining));
    }

    updateQConnectors();
    qRecalc();
}

/* ── Create a Quill-backed block ── */
function createQBlock(initialText, depth, wildcardValues) {
    var id = qState.nextId++;
    if (typeof depth === 'boolean') depth = depth ? 1 : 0; // backwards compat

    var blockEl = document.createElement('div');
    blockEl.className = 'q-block' + (depth > 0 ? ' q-block--child' : '');
    blockEl.setAttribute('data-block-id', id);
    blockEl.setAttribute('data-depth', depth);

    var viewEl = document.createElement('div');
    viewEl.className = 'q-block-view editor-line' + (depth > 0 ? ' editor-line--child visible' : '');
    if (depth > 0) viewEl.style.paddingLeft = (depth * 2) + 'ch';
    blockEl.appendChild(viewEl);

    var editEl = document.createElement('div');
    editEl.className = 'q-block-edit';

    var editConn = null;
    if (depth > 0) {
        editConn = document.createElement('span');
        editConn.className = 'q-edit-connector';
        editConn.style.paddingLeft = (depth * 2) + 'ch';
        editConn.textContent = '\u2514\u2500\u2500 ';
        editEl.appendChild(editConn);
    }

    var quillContainer = document.createElement('div');
    quillContainer.className = 'q-quill-wrap';
    editEl.appendChild(quillContainer);

    // Floating hint on the gradient border
    var hint = document.createElement('span');
    hint.className = 'q-add-child-hint';
    hint.innerHTML = '<kbd>Ctrl</kbd>+<kbd>Enter</kbd> Add Child';
    if (!initialText.replace(/\u200B/g, '').trim()) hint.style.display = 'none';
    editEl.appendChild(hint);

    blockEl.appendChild(editEl);

    var quill = new Quill(quillContainer, {
        theme: 'snow',
        modules: { toolbar: false },
        placeholder: ''
    });

    var wcParsed = parseQWildcards(initialText);
    if (wcParsed.length > 0) {
        var ops = [];
        var cursor = 0;
        wcParsed.forEach(function(wc) {
            if (wc.pos > cursor) ops.push({ insert: initialText.slice(cursor, wc.pos) });
            ops.push({ insert: { wildcard: { name: wc.name } } });
            cursor = wc.pos + wc.len;
        });
        var rem = initialText.slice(cursor);
        if (rem) ops.push({ insert: rem });
        // Ensure trailing text node so browser can anchor caret after last embed
        else ops.push({ insert: '\u200B' });
        ops.push({ insert: '\n' });
        quill.setContents(ops, 'silent');
    } else {
        quill.setText(initialText, 'silent');
    }

    quill.on('text-change', function(delta, oldDelta, source) {
        if (source !== 'user') return;
        convertQWildcards(quill);
        // Toggle add-child hint visibility based on content
        var text = serializeQuill(quill).replace(/\u200B/g, '').trim();
        hint.style.display = text ? '' : 'none';
    });

    // Show popover when cursor lands adjacent to a wildcard chip
    quill.on('selection-change', function(range, oldRange, source) {
        if (!range || range.length !== 0) return; // only collapsed cursor
        if (source !== 'user') return;
        var idx = range.index;

        // Check leaf at cursor (right side: cursor|wildcard) and
        // leaf before cursor (left side: wildcard|cursor) — only if immediately adjacent
        var chipNode = null;
        var leafAt = quill.getLeaf(idx);
        if (leafAt && leafAt[0] && leafAt[0].constructor.blotName === 'wildcard') {
            chipNode = leafAt[0].domNode;
        }
        if (!chipNode && idx > 0) {
            var leafBefore = quill.getLeaf(idx - 1);
            if (leafBefore && leafBefore[0] && leafBefore[0].constructor.blotName === 'wildcard') {
                // Verify cursor is immediately after the wildcard (blotPos + 1 === idx)
                var blotPos = quill.getIndex(leafBefore[0]);
                if (blotPos + 1 === idx) {
                    chipNode = leafBefore[0].domNode;
                }
            }
        }

        if (chipNode) {
            // Only open if not already showing this chip's popover
            if (!_activePopoverWc || _activePopoverWc.reelEl !== chipNode) {
                openChipPopover(chipNode);
            }
        } else if (_popoverIsChip) {
            // Cursor moved away from any wildcard — close chip popover
            closePopover();
        }
    });

    var block = {
        id: id,
        depth: depth,
        get isChild() { return this.depth > 0; },
        lineEl: blockEl,
        viewEl: viewEl,
        editEl: editEl,
        quill: quill,
        wildcards: [],
        _prevWildcards: null,
        _connector: null,
        _editConnector: editConn
    };

    if (wildcardValues) {
        block._prevWildcards = Object.keys(wildcardValues).map(function(name) {
            var color = nextQColor();
            var vals = wildcardValues[name].slice();
            // Populate chipRegistry so hydrateChip can read values immediately
            if (!qState.chipRegistry[name]) {
                qState.chipRegistry[name] = { values: vals, color: color, chipEls: [] };
            } else {
                qState.chipRegistry[name].values = vals;
                qState.chipRegistry[name].color = color;
            }
            return { name: name, values: vals, color: color };
        });
    }

    viewEl.addEventListener('click', function(e) {
        if (e.target.closest('.reel.interactive')) return;
        switchToEdit(block);
    });

    hint.addEventListener('click', function(e) {
        e.stopPropagation();
        var text = serializeQuill(block.quill).replace(/\u200B/g, '').trim();
        if (!text) return;
        addChildFromBlock(block);
    });

    qState.blocks.push(block);
    buildBlockView(block);
    return block;
}

/* ── Find the parent block for a given block (nearest shallower block above) ── */
function findParentBlock(block) {
    var idx = qState.blocks.indexOf(block);
    if (idx <= 0 || block.depth === 0) return null;
    for (var p = idx - 1; p >= 0; p--) {
        if (qState.blocks[p].depth < block.depth) return qState.blocks[p];
    }
    return null;
}

/* ── Find direct children of a given block ── */
function getChildrenOf(parentBlock) {
    var parentIdx = qState.blocks.indexOf(parentBlock);
    var children = [];
    for (var i = parentIdx + 1; i < qState.blocks.length; i++) {
        if (qState.blocks[i].depth <= parentBlock.depth) break; // hit sibling or higher
        if (qState.blocks[i].depth === parentBlock.depth + 1) {
            children.push(qState.blocks[i]);
        }
    }
    return children;
}

/* ── Get the full ancestor chain of a block (bottom-up) ── */
function getAncestors(block) {
    var ancestors = [];
    var current = block;
    while (current && current.depth > 0) {
        var parent = findParentBlock(current);
        if (parent) ancestors.push(parent);
        current = parent;
    }
    return ancestors;
}

/* ── Add child block from edit mode ── */
function addChildFromBlock(sourceBlock) {
    // Prevent blur race: mark that we're adding a child
    qState._addingChild = true;

    // Finish editing the source block first
    syncRegistryToBlocks();
    sourceBlock._prevWildcards = sourceBlock.wildcards.slice();
    sourceBlock.lineEl.classList.remove('editing');
    clearEditFocus();
    buildBlockView(sourceBlock);

    // New child is one level deeper than the source
    var childDepth = sourceBlock.depth + 1;

    // Insert as first child: right after the source block
    var sourceIdx = qState.blocks.indexOf(sourceBlock);
    var insertIdx = sourceIdx + 1;

    // Create a new empty child block at the correct depth
    var newBlock = createQBlock('', childDepth, null);

    // createQBlock pushes to the end — remove first so insertIdx stays valid
    var pushIdx = qState.blocks.indexOf(newBlock);
    if (pushIdx !== -1) qState.blocks.splice(pushIdx, 1);

    // Insert into DOM at the correct position
    var refBlock = qState.blocks[insertIdx];
    if (refBlock) {
        qBlocksEl.insertBefore(newBlock.lineEl, refBlock.lineEl);
    } else {
        qBlocksEl.appendChild(newBlock.lineEl);
    }

    // Insert at correct position in array
    qState.blocks.splice(insertIdx, 0, newBlock);

    updateQConnectors();

    // Use rAF to ensure DOM is ready before focusing the new editor
    requestAnimationFrame(function() {
        qState._addingChild = false;
        switchToEdit(newBlock);
    });
}

/* ── Depth-based focus fade ── */
function applyEditFocus(activeBlock) {
    var activeIdx = qState.blocks.indexOf(activeBlock);
    var childCount = 0;

    // Build set of ancestor indices (entire parent tree stays visible)
    var ancestors = getAncestors(activeBlock);
    var ancestorSet = {};
    ancestors.forEach(function(a) {
        ancestorSet[qState.blocks.indexOf(a)] = true;
    });

    qState.blocks.forEach(function(b, i) {
        if (b === activeBlock) {
            b.lineEl.style.opacity = '';
            return;
        }
        // Keep entire ancestor chain visible
        if (ancestorSet[i]) {
            b.lineEl.style.opacity = '';
            return;
        }
        // Determine if this block is a descendant of the active block
        var isDescendant = (i > activeIdx) && (b.depth > activeBlock.depth);
        if (isDescendant) {
            // Check there's no block at same or shallower depth between active and this
            var broken = false;
            for (var j = activeIdx + 1; j < i; j++) {
                if (qState.blocks[j].depth <= activeBlock.depth) { broken = true; break; }
            }
            if (broken) isDescendant = false;
        }

        if (isDescendant) {
            childCount++;
            var opacity = Math.max(0.5 - (childCount - 1) * 0.1, 0.15);
            b.lineEl.style.opacity = opacity;
        } else {
            b.lineEl.style.opacity = 0.25;
        }
    });
}

function clearEditFocus() {
    qState.blocks.forEach(function(b) {
        b.lineEl.style.opacity = '';
    });
}

/* ── Switch block to edit mode ── */
function switchToEdit(block) {
    closePopover();
    block.lineEl.classList.add('editing');
    applyEditFocus(block);
    block.quill.focus();
    block.quill.setSelection(block.quill.getLength() - 1, 0);

    function finishEdit() {
        if (!block.lineEl.classList.contains('editing')) return;
        clearEditFocus();
        syncRegistryToBlocks();
        var serialized = serializeQuill(block.quill).replace(/\u200B/g, '').trim();
        if (!serialized) {
            // Empty block — remove it
            block.lineEl.remove();
            var idx = qState.blocks.indexOf(block);
            if (idx !== -1) qState.blocks.splice(idx, 1);
            updateQConnectors();
            qRecalc();
            return;
        }
        block._prevWildcards = block.wildcards.slice();
        block.lineEl.classList.remove('editing');
        buildBlockView(block);
    }

    var keyHandler = function(e) {
        if (e.key === 'Enter' && (e.ctrlKey || e.metaKey)) {
            e.preventDefault();
            var text = serializeQuill(block.quill).replace(/\u200B/g, '').trim();
            if (!text) return; // prevent add child when empty
            cleanup(); addChildFromBlock(block); return;
        }
        if (e.key === 'Enter') { e.preventDefault(); cleanup(); finishEdit(); }
        else if (e.key === 'Escape') { cleanup(); finishEdit(); }
    };
    var blurHandler = function() {
        setTimeout(function() {
            if (_activePopoverWc) return; // popover open — don't finish edit
            if (qState._addingChild) return; // adding child — don't finish edit
            if (block.lineEl.classList.contains('editing')) { cleanup(); finishEdit(); }
        }, 200);
    };
    function cleanup() {
        block.quill.root.removeEventListener('keydown', keyHandler);
        block.quill.root.removeEventListener('blur', blurHandler);
    }
    block.quill.root.addEventListener('keydown', keyHandler);
    block.quill.root.addEventListener('blur', blurHandler);
}

/* ── Initialize Quill section ── */
function initQuillSection() {
    var parentBlock = createQBlock(
        BASE + ', __season__, __style__',
        false,
        { season: SEASONS.slice(), style: STYLES.slice() }
    );
    qBlocksEl.appendChild(parentBlock.lineEl);

    var childBlock = createQBlock(
        'with __detail__ level of detail',
        true,
        { detail: ['high', 'medium', 'sketch'] }
    );
    qBlocksEl.appendChild(childBlock.lineEl);

    var persistentContainer = document.getElementById('quill-persistent-editor');
    var persistentQuill = new Quill(persistentContainer, {
        theme: 'snow',
        modules: { toolbar: false },
        placeholder: 'type text, use __double_underscores__ for wildcards'
    });

    persistentQuill.on('text-change', function(delta, oldDelta, source) {
        if (source !== 'user') return;
        setTimeout(function() { convertQWildcards(persistentQuill); }, 0);
    });

    persistentQuill.root.addEventListener('keydown', function(e) {
        if (e.key !== 'Enter') return;
        e.preventDefault();
        var serialized = serializeQuill(persistentQuill);
        if (!serialized.trim()) return;

        updateQConnectors();
        var newBlock = createQBlock(serialized, true, null);
        qBlocksEl.appendChild(newBlock.lineEl);
        updateQConnectors();
        persistentQuill.setText('', 'silent');
    });

    qState.persistentQuill = persistentQuill;
}

/* ══════════════════════════════════════════════════
   START
   ══════════════════════════════════════════════════ */
initQuillSection();
</script>
</body>
</html>
