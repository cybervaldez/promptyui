<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>PromptyUI — Try It</title>
<style>
:root {
    --bg-deep: #0a0a0a;
    --bg-surface: #161b22;
    --bg-elevated: #1c2128;
    --text-primary: #e6edf3;
    --text-secondary: #8b949e;
    --text-muted: #484f58;
    --accent-green: #3fb950;
    --accent-amber: #ff6b35;
    --accent-blue: #58a6ff;
    --accent-purple: #bc8cff;
    --reel-label: #e8943a;
    --reel-value: #529CCA;
    --reel-bg: rgba(82, 156, 202, 0.08);
    --font-mono: 'Courier New', Courier, monospace;
}

*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

body {
    font-family: var(--font-mono);
    background: var(--bg-deep);
    color: var(--text-primary);
    overflow-x: hidden;
    overflow-y: auto;
}

/* ── Editor lines ── */
.editor-line {
    font-size: clamp(0.85rem, 1.8vw, 1.1rem);
    line-height: 2.6em;
    white-space: nowrap;
    overflow: visible;
    color: var(--text-secondary);
    margin-top: 0.4em;
}

.editor-line--child {
    opacity: 0;
    transform: translateY(8px);
    transition: opacity 0.5s ease, transform 0.5s ease;
}

.editor-line--child.visible {
    opacity: 1;
    transform: translateY(0);
}

.tree-connector {
    color: var(--text-muted);
    user-select: none;
    transition: color 0.3s ease;
}
.tree-connector.tree-active {
    color: var(--reel-label);
}

/* ── Inline reel ── */
.reel {
    display: inline-block;
    position: relative;
    vertical-align: middle;
    padding: 0 8px;
    border-radius: 4px;
    background: var(--reel-bg);
    overflow: visible;
    height: 1.6em;
    line-height: 1.6em;
}

.reel.interactive {
    cursor: pointer;
    transition: background 0.2s ease;
}

.reel.interactive:hover {
    background: rgba(82, 156, 202, 0.18);
}

.reel.interactive.popover-open {
    background: rgba(82, 156, 202, 0.22);
    outline: 1px solid rgba(82, 156, 202, 0.3);
}

.reel-badge {
    position: absolute;
    top: -0.55em;
    right: -0.65em;
    min-width: 1.3em;
    height: 1.3em;
    border-radius: 9999px;
    background: var(--bg-surface);
    color: var(--reel-label);
    font-size: 0.5em;
    font-weight: 700;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 0 0.3em;
    line-height: 1;
    pointer-events: none;
    z-index: 3;
}

.reel-label {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    text-align: center;
    color: var(--reel-label);
    font-size: inherit;
    line-height: 1.6em;
    white-space: nowrap;
    z-index: 2;
    pointer-events: none;
    transform-origin: center center;
    transform: translateY(0) scale(1);
    opacity: 1;
    transition: transform 0.6s cubic-bezier(0.4, 0, 0.2, 1),
                opacity 0.15s ease;
}

.reel-label.float {
    transform: translateY(-1.3em) scale(0.55);
    opacity: 1;
}

.reel-window {
    display: block;
    overflow: hidden;
    width: 100%;
    height: 0;
    transition: height 0.4s cubic-bezier(0.4, 0, 0.2, 1);
    -webkit-mask-image: linear-gradient(to bottom, transparent 0%, black 15%, black 85%, transparent 100%);
    mask-image: linear-gradient(to bottom, transparent 0%, black 15%, black 85%, transparent 100%);
}

.reel-window.open {
    height: 1.6em;
}

.reel-track {
    display: flex;
    flex-direction: column;
    align-items: center;
    opacity: 0;
    transition: transform 0.8s cubic-bezier(0.22, 1, 0.36, 1),
                opacity 0.4s ease;
}

.reel-track.visible {
    opacity: 1;
}

.reel-item {
    white-space: nowrap;
    font-size: inherit;
    color: var(--reel-value);
    line-height: 1.6em;
    height: 1.6em;
    display: flex;
    align-items: center;
    justify-content: center;
}
.reel-item.placeholder {
    color: var(--text-muted);
    font-weight: 300;
}

/* ── Formula ── */
.demo-formula {
    font-size: clamp(0.75rem, 1.4vw, 1rem);
    color: var(--text-muted);
    display: flex;
    align-items: center;
    gap: 0.5ch;
    flex-wrap: wrap;
    justify-content: center;
}

.formula-term {
    font-weight: 500;
}

.formula-count {
    opacity: 0.55;
}

.formula-x {
    color: var(--text-muted);
}

/* ── Big odometer count ── */
.demo-count {
    font-size: clamp(2rem, 5vw, 3.5rem);
    font-weight: 700;
    color: var(--accent-amber);
    display: flex;
    align-items: center;
    justify-content: center;
    line-height: 1;
}

.odo-wrap {
    display: inline-block;
    height: 1em;
    overflow: hidden;
    line-height: 1;
}

.odo-strip { display: block; }

.odo-d {
    display: block;
    height: 1em;
    line-height: 1;
    text-align: center;
}

.odo-comma { line-height: 1; }

.math-label {
    font-size: 0.8rem;
    color: var(--text-muted);
    letter-spacing: 0.12em;
    text-transform: uppercase;
    opacity: 0;
    transition: opacity 0.4s ease;
}

.math-label.visible {
    opacity: 1;
}

/* ── Value popover ── */
.wc-popover {
    position: fixed;
    z-index: 100;
    background: var(--bg-elevated);
    border: 1px solid rgba(72, 79, 88, 0.5);
    border-radius: 8px;
    padding: 0.8rem;
    min-width: 200px;
    max-width: 320px;
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
}

.wc-popover-name {
    font-size: 0.7rem;
    color: var(--reel-label);
    text-transform: uppercase;
    letter-spacing: 0.1em;
    margin-bottom: 0.5rem;
}
.wc-popover-tab-landing {
    display: none;
    text-align: center;
    padding: 0.6em 0;
    font-size: 0.7rem;
    color: var(--text-muted);
}
.wc-popover-tab-landing kbd {
    font-family: var(--font-mono);
    font-size: 0.65rem;
    font-weight: 700;
    letter-spacing: 0.05em;
    color: var(--accent-amber);
    background: rgba(255, 107, 53, 0.08);
    border: 1px solid rgba(255, 107, 53, 0.3);
    border-radius: 3px;
    padding: 0.15em 0.4em;
    line-height: 1;
    animation: hint-key-glow 2s ease-in-out infinite;
}
@media (prefers-reduced-motion: reduce) {
    .wc-popover-tab-landing kbd { animation: none; border-color: rgba(255, 107, 53, 0.5); }
}

.wc-popover-pills {
    display: flex;
    flex-wrap: wrap;
    gap: 0.3rem;
    margin-bottom: 0.5rem;
}

.wc-pill {
    display: inline-flex;
    align-items: center;
    gap: 0.3em;
    font-size: 0.8rem;
    color: var(--reel-value);
    background: rgba(82, 156, 202, 0.1);
    border: 1px solid rgba(82, 156, 202, 0.2);
    border-radius: 3px;
    padding: 0.15em 0.4em;
}

.wc-pill-remove {
    cursor: pointer;
    color: var(--text-muted);
    font-size: 0.9em;
    line-height: 1;
    transition: color 0.15s;
}

.wc-pill-remove:hover {
    color: #f85149;
}

.wc-popover-input {
    width: 100%;
    font-family: var(--font-mono);
    font-size: 0.8rem;
    color: var(--text-primary);
    background: var(--bg-deep);
    border: 1px solid rgba(72, 79, 88, 0.4);
    border-radius: 4px;
    padding: 0.35em 0.5em;
    outline: none;
}

.wc-popover-input:focus {
    border-color: var(--reel-value);
}
/* ── Inline editor hint (floating below cursor) ── */
.q-inline-hint {
    position: absolute;
    z-index: 20;
    pointer-events: none;
    font-family: var(--font-mono);
    font-size: 0.6rem;
    color: var(--text-muted);
    white-space: nowrap;
    opacity: 0;
    transition: opacity 0.15s ease;
}
.q-inline-hint.visible {
    opacity: 1;
}
.q-inline-hint kbd {
    font-family: var(--font-mono);
    font-size: 0.6rem;
    font-weight: 700;
    letter-spacing: 0.05em;
    color: var(--accent-amber);
    background: rgba(255, 107, 53, 0.08);
    border: 1px solid rgba(255, 107, 53, 0.3);
    border-radius: 3px;
    padding: 0.1em 0.35em;
    line-height: 1;
    animation: hint-key-glow 2s ease-in-out infinite;
}
.q-inline-hint .hint-dim {
    color: var(--text-secondary);
}
@keyframes hint-key-glow {
    0%, 100% { box-shadow: 0 0 3px rgba(255, 107, 53, 0.1); border-color: rgba(255, 107, 53, 0.2); }
    50% { box-shadow: 0 0 10px rgba(255, 107, 53, 0.4), 0 0 3px rgba(255, 107, 53, 0.2); border-color: rgba(255, 107, 53, 0.5); }
}
@media (prefers-reduced-motion: reduce) {
    .q-inline-hint kbd { animation: none; border-color: rgba(255, 107, 53, 0.5); }
}

.wc-popover-input::placeholder {
    color: var(--text-muted);
    font-size: 0.75rem;
}

/* ══════════════════════════════════════
   Quill Section
   ══════════════════════════════════════ */
.quill-section {
    min-height: 100vh;
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 6rem 2rem 4rem;
    border-top: 1px solid rgba(72, 79, 88, 0.2);
}

.quill-title {
    font-size: clamp(1.2rem, 3vw, 1.8rem);
    font-weight: 600;
    color: var(--text-primary);
    margin-bottom: 0.4rem;
}

.quill-subtitle {
    font-size: clamp(0.75rem, 1.4vw, 0.9rem);
    color: var(--text-muted);
    margin-bottom: 2.5rem;
}

.quill-editor-area {
    width: 100%;
    max-width: 700px;
    background: var(--bg-surface);
    border: 1px solid rgba(72, 79, 88, 0.3);
    border-radius: 8px;
    padding: 1.5rem 2rem;
}

.quill-blocks { min-height: 6em; overflow: visible; }

.q-block { position: relative; margin-bottom: 0.3em; overflow: visible; transition: margin-bottom 0.3s ease, opacity 0.3s ease; }
.q-block.editing { margin-bottom: 1.8em; }

.q-block-view {
    cursor: text;
    padding: 0.2em 0;
    border-radius: 4px;
    transition: background 0.15s;
}
.q-block-view:hover { background: rgba(72, 79, 88, 0.1); }
.q-block-edit { display: none; padding-bottom: 0; transition: padding-bottom 0.3s ease; }
.q-block.editing .q-block-view { display: none; }
.q-block.editing .q-block-edit {
    display: flex;
    align-items: baseline;
    position: relative;
    padding-bottom: 1.2em;
}
@keyframes border-shimmer {
    0%   { background-position: -100% 0, 0 0; }
    100% { background-position: 200% 0, 0 0; }
}
.q-block.editing .q-block-edit::after {
    content: '';
    position: absolute;
    bottom: 0;
    left: 0;
    right: 0;
    height: 1px;
    background:
        radial-gradient(ellipse 8% 100% at 50% 50%, rgba(82,156,202,0.9), transparent) no-repeat,
        linear-gradient(to right, transparent, var(--reel-value), transparent);
    background-size: 30% 100%, 100% 100%;
    background-position: -100% 0, 0 0;
    opacity: 0.4;
    animation: border-shimmer 0.9s 0.25s ease-out forwards;
}
.q-block.editing .q-block-actions {
    position: absolute;
    bottom: 0;
    left: 50%;
    transform: translateX(-50%) translateY(50%) translateY(4px);
    display: flex;
    gap: 0.6em;
    z-index: 4;
    white-space: nowrap;
    user-select: none;
    -webkit-tap-highlight-color: transparent;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.25s ease, transform 0.25s ease;
}
.q-block.editing .q-block-actions.visible {
    opacity: 1;
    pointer-events: auto;
    transform: translateX(-50%) translateY(50%);
}
.q-block-action {
    font-family: var(--font-mono);
    font-size: 8px;
    color: var(--text-secondary);
    background: var(--bg-surface);
    padding: 0.2em 0.5em;
    border-radius: 2px;
    cursor: pointer;
    letter-spacing: 0.03em;
    text-transform: uppercase;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    display: flex;
    align-items: center;
    gap: 0.3em;
    touch-action: manipulation;
    transition: color 0.15s, background 0.15s;
}
.q-block-action:hover { color: var(--reel-value); }
.q-block-action:active { background: rgba(82, 156, 202, 0.1); }
.q-action-hint {
    font-size: 7px;
    color: var(--text-muted);
    text-transform: none;
}
@media (pointer: coarse) {
    .q-action-hint { display: none; }
}
@media (hover: none) {
    .q-action-hint { display: none; }
}
.q-block.tree-hidden {
    opacity: 0 !important;
    pointer-events: none;
}

.q-edit-connector {
    color: var(--text-muted);
    user-select: none;
    white-space: nowrap;
    line-height: 2.6em;
    flex-shrink: 0;
    margin-right: 0.5ch;
    transition: color 0.3s ease;
}
.q-edit-connector.tree-active {
    color: var(--reel-label);
}

.q-quill-wrap { flex: 1; min-width: 0; }

.q-block-edit .ql-container.ql-snow {
    border: none;
    font-family: var(--font-mono);
    font-size: clamp(0.85rem, 1.8vw, 1.1rem);
    background: transparent;
    overflow: visible;
}
.q-block-edit .ql-editor {
    color: var(--text-secondary);
    padding: 0.2em 0;
    min-height: auto;
    line-height: 2.6em;
    caret-color: var(--accent-amber);
    overflow: visible;
    outline: none;
    position: relative;
}
.q-block-edit .ql-editor.ql-blank::before {
    content: attr(data-placeholder);
    color: var(--text-muted);
    font-style: italic;
    pointer-events: none;
    position: absolute;
    left: 0;
    right: 0;
}

.q-add-block {
    padding: 0.4em 0.2em;
    margin-top: 0.3em;
    color: var(--text-muted);
    font-size: clamp(0.8rem, 1.6vw, 0.95rem);
    font-style: italic;
    cursor: pointer;
    border-radius: 4px;
    transition: color 0.2s, background 0.2s;
    user-select: none;
    letter-spacing: 0.03em;
}
.q-add-block:hover {
    color: var(--text-secondary);
    background: rgba(72, 79, 88, 0.1);
}
.q-add-block:active {
    background: rgba(82, 156, 202, 0.08);
}

.ql-wildcard-chip {
    display: inline-block;
    position: relative;
    vertical-align: middle;
    padding: 0 8px;
    border-radius: 4px;
    background: var(--reel-bg);
    cursor: pointer;
    height: 1.6em;
    line-height: 1.6em;
    overflow: visible;
    transition: background 0.2s ease;
}
/* Quill Embed wraps content in an inline span — make it layout-transparent */
.ql-wildcard-chip > span:not([class]) {
    display: contents;
}
.ql-wildcard-chip:hover {
    background: rgba(82, 156, 202, 0.18);
}
.ql-wildcard-chip.popover-open {
    background: rgba(82, 156, 202, 0.22);
    outline: 1px solid rgba(82, 156, 202, 0.3);
}
.ql-wc-label {
    position: absolute;
    top: 0; left: 0; right: 0;
    text-align: center;
    color: var(--reel-label);
    font-family: var(--font-mono);
    font-size: inherit;
    line-height: 1.6em;
    white-space: nowrap;
    pointer-events: none;
    transform-origin: center center;
    transform: translateY(0) scale(1);
    opacity: 1;
    transition: transform 0.6s cubic-bezier(0.4, 0, 0.2, 1),
                opacity 0.15s ease;
    z-index: 2;
}
.ql-wc-label.float {
    transform: translateY(-1.3em) scale(0.55);
    opacity: 1;
}
.ql-wc-window {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    display: block;
    overflow: hidden;
    height: 0;
    transition: height 0.4s cubic-bezier(0.4, 0, 0.2, 1);
    -webkit-mask-image: linear-gradient(to bottom, transparent 0%, black 15%, black 85%, transparent 100%);
    mask-image: linear-gradient(to bottom, transparent 0%, black 15%, black 85%, transparent 100%);
}
.ql-wc-window.open {
    height: 1.6em;
}
.ql-wc-track {
    display: flex;
    flex-direction: column;
    align-items: center;
    opacity: 0;
    transition: transform 0.8s cubic-bezier(0.22, 1, 0.36, 1),
                opacity 0.4s ease;
}
.ql-wc-track.visible {
    opacity: 1;
}
.ql-wc-item {
    white-space: nowrap;
    font-size: inherit;
    color: var(--reel-value);
    line-height: 1.6em;
    height: 1.6em;
    display: flex;
    align-items: center;
    justify-content: center;
}
.ql-wc-item.placeholder {
    color: var(--text-muted);
    font-size: 1.1em;
    font-style: normal;
    font-weight: 300;
}
.ql-wc-badge {
    position: absolute;
    top: -0.55em;
    right: -0.65em;
    min-width: 1.3em;
    height: 1.3em;
    border-radius: 9999px;
    background: var(--bg-surface);
    color: var(--reel-label);
    font-size: 0.5em;
    font-weight: 700;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 0 0.3em;
    line-height: 1;
    pointer-events: none;
    z-index: 10;
}

.quill-formula-area {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 0.4rem;
    margin-top: 2.5rem;
}
.quill-count { font-size: clamp(2rem, 5vw, 3.5rem); }
.q-save-continue-btn {
    margin-top: 1rem;
    padding: 0.5em 1.6em;
    font-family: var(--font-mono);
    font-size: 0.85rem;
    color: var(--text-primary);
    background: var(--bg-elevated);
    border: 1px solid var(--text-muted);
    border-radius: 4px;
    cursor: pointer;
    transition: background 0.15s, border-color 0.15s;
}
.q-save-continue-btn:hover {
    background: rgba(82, 156, 202, 0.12);
    border-color: var(--reel-value);
    color: var(--reel-value);
}

/* ═══════════════════════════════════════════
   SECTION 3: Navigating Compositions
   ═══════════════════════════════════════════ */

/* ── Section shared ── */
.demo-section {
    padding: 4rem 2rem 3rem;
    max-width: 720px;
    margin: 0 auto;
}
.demo-section-title {
    font-size: 1.6rem;
    color: var(--text-primary);
    margin-bottom: 0.3rem;
}
.demo-section-subtitle {
    color: var(--text-secondary);
    font-size: 0.9rem;
    margin-bottom: 2rem;
}

/* ── Composition navigator (matches live app right sidebar) ── */
.preview-nav {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 0.6rem;
    margin-bottom: 1.5rem;
}
.preview-nav-btn {
    background: var(--bg-elevated);
    border: 1px solid rgba(255,255,255,0.1);
    color: var(--text-primary);
    padding: 6px 12px;
    border-radius: 4px;
    cursor: pointer;
    font-family: var(--font-mono);
    font-size: 1.1rem;
    line-height: 1;
}
.preview-nav-btn:hover { border-color: var(--reel-value); color: var(--reel-value); }
.preview-nav-btn.shuffle { font-size: 0.95rem; padding: 6px 10px; }
.preview-nav-label {
    font-size: 0.95rem;
    color: var(--text-secondary);
    min-width: 8ch;
    text-align: center;
    font-family: var(--font-mono);
}

/* ── Resolved text (shared by flat + bucket nav) ── */
.preview-resolved {
    background: var(--bg-surface);
    border: 1px solid rgba(255,255,255,0.06);
    border-radius: 8px;
    padding: 1.2rem 1.5rem;
    margin-bottom: 1rem;
    line-height: 1.8;
}
.preview-block { color: var(--text-primary); font-size: 0.95rem; }
.preview-block-child {
    padding-left: 2rem;
    border-left: 2px solid var(--text-muted);
    margin-top: 0.5rem;
    color: var(--text-secondary);
}

/* ── Wildcard tags (matches live app name="value" style) ── */
.preview-pills {
    display: flex;
    gap: 8px;
    flex-wrap: wrap;
    margin-bottom: 1rem;
}
.preview-pill {
    display: inline-flex;
    align-items: center;
    gap: 2px;
    background: var(--reel-bg);
    border-radius: 4px;
    padding: 3px 8px;
    font-size: 0.8rem;
}
.preview-pill-name { color: var(--reel-label); }
.preview-pill-value { color: var(--reel-value); font-weight: 600; }

/* ── Decomposition ── */
.preview-breakdown {
    background: var(--bg-elevated);
    border-radius: 6px;
    padding: 0.8rem 1rem;
    font-size: 0.8rem;
    color: var(--text-secondary);
    font-family: var(--font-mono);
}

/* ── Scale-it-up divider ── */
.scale-divider {
    display: flex;
    align-items: center;
    gap: 1rem;
    margin: 2.5rem 0 1.5rem;
    color: var(--text-muted);
    font-size: 0.8rem;
}
.scale-divider::before, .scale-divider::after {
    content: '';
    flex: 1;
    height: 1px;
    background: rgba(255,255,255,0.06);
}

/* ── Bucket control ── */
.bucket-control {
    display: flex;
    align-items: center;
    gap: 1rem;
    margin-bottom: 1.5rem;
}
.bucket-label { color: var(--text-secondary); font-size: 0.85rem; }
.bucket-slider { width: 120px; accent-color: var(--reel-value); }
.bucket-slider-value {
    color: var(--reel-value);
    font-weight: bold;
    font-size: 1.1rem;
    min-width: 2ch;
}

/* ── Bucket visual (bracket groups) ── */
.bucket-visual {
    background: var(--bg-surface);
    border: 1px solid rgba(255,255,255,0.06);
    border-radius: 8px;
    padding: 1rem 1.2rem;
    margin-bottom: 1.5rem;
}
.bucket-wc-row {
    margin-bottom: 0.8rem;
}
.bucket-wc-name {
    color: var(--reel-label);
    font-size: 0.8rem;
    margin-bottom: 4px;
}
.bucket-group {
    display: inline-flex;
    gap: 4px;
    border: 1px solid rgba(255,255,255,0.1);
    border-radius: 4px;
    padding: 3px 6px;
    margin-right: 8px;
    transition: border-color 0.2s;
}
.bucket-group.active {
    border-color: var(--reel-value);
    background: rgba(82, 156, 202, 0.08);
}
.bucket-val {
    font-size: 0.75rem;
    color: var(--text-secondary);
    padding: 1px 4px;
    border-radius: 2px;
}
.bucket-val.active {
    color: var(--reel-value);
    background: rgba(82, 156, 202, 0.15);
}

/* ── Bucket navigator ── */
.bucket-nav {
    display: flex;
    gap: 2rem;
    align-items: center;
    margin-bottom: 1rem;
    flex-wrap: wrap;
}
.bucket-nav-coarse, .bucket-nav-fine {
    display: flex;
    align-items: center;
    gap: 0.5rem;
}
.bucket-nav-label {
    color: var(--text-secondary);
    font-size: 0.8rem;
}
.bucket-fine-select {
    background: var(--bg-elevated);
    border: 1px solid rgba(255,255,255,0.1);
    color: var(--text-primary);
    padding: 4px 8px;
    border-radius: 4px;
    font-family: var(--font-mono);
    font-size: 0.8rem;
}

/* ═══════════════════════════════════════════
   SECTION 5: Annotations
   ═══════════════════════════════════════════ */

/* ── Annotation layers ── */
.ann-layers {
    display: flex;
    align-items: flex-start;
    gap: 8px;
    margin-bottom: 2rem;
    overflow-x: auto;
    padding-bottom: 0.5rem;
}
.ann-layer {
    background: var(--bg-surface);
    border: 1px solid rgba(255,255,255,0.06);
    border-radius: 8px;
    padding: 0.6rem 0.8rem;
    min-width: 120px;
    flex: 1;
}
.ann-layer-resolved {
    border-color: var(--accent-green);
    background: rgba(63, 185, 80, 0.05);
}
.ann-layer-header {
    font-size: 0.7rem;
    text-transform: uppercase;
    color: var(--text-muted);
    letter-spacing: 0.05em;
    margin-bottom: 0.4rem;
}
.ann-layer-body { font-size: 0.8rem; }
.ann-merge-arrow {
    color: var(--text-muted);
    font-size: 1.2rem;
    padding-top: 1.2rem;
    flex-shrink: 0;
}

/* key-value rows inside layers */
.ann-kv { display: flex; justify-content: space-between; gap: 8px; padding: 2px 0; }
.ann-kv-key { color: var(--reel-label); }
.ann-kv-val { color: var(--text-primary); }
.ann-kv-val.null-sentinel { color: var(--accent-amber); text-decoration: line-through; }
.ann-kv-val.inherited { color: var(--text-secondary); font-style: italic; }
.ann-kv-source {
    font-size: 0.65rem;
    color: var(--text-muted);
    background: var(--bg-elevated);
    padding: 0 4px;
    border-radius: 2px;
    margin-left: 4px;
}

/* ── Block cards with badges ── */
.ann-block-card {
    background: var(--bg-surface);
    border: 1px solid rgba(255,255,255,0.06);
    border-radius: 8px;
    padding: 0.8rem 1rem;
    margin-bottom: 0.8rem;
    cursor: pointer;
    transition: border-color 0.15s;
}
.ann-block-card:hover { border-color: rgba(255,255,255,0.15); }
.ann-block-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
}
.ann-block-text { font-size: 0.9rem; color: var(--text-primary); }
.ann-block-badges { display: flex; gap: 6px; align-items: center; }

/* Badge (tag icon + count) */
.ann-badge {
    display: inline-flex;
    align-items: center;
    gap: 3px;
    font-size: 0.7rem;
    color: var(--text-muted);
    background: var(--bg-elevated);
    padding: 2px 6px;
    border-radius: 3px;
}
.ann-badge-icon { font-size: 0.6rem; }

/* Inline universals on card */
.ann-card-comment {
    font-size: 0.75rem;
    color: var(--text-secondary);
    font-style: italic;
    margin-top: 4px;
}
.ann-card-priority {
    font-size: 0.65rem;
    padding: 1px 5px;
    border-radius: 3px;
    background: rgba(88, 166, 255, 0.12);
    color: var(--accent-blue);
}
.ann-card-draft {
    font-size: 0.65rem;
    padding: 1px 5px;
    border-radius: 3px;
    background: rgba(255, 107, 53, 0.12);
    color: var(--accent-amber);
}

/* ── Slide-in annotation editor ── */
.ann-block-editor {
    max-height: 0;
    overflow: hidden;
    transition: max-height 0.3s ease;
    border-top: 1px solid rgba(255,255,255,0.06);
    margin-top: 0.6rem;
    padding-top: 0;
}
.ann-block-editor.open {
    max-height: 400px;
    padding-top: 0.6rem;
}
.ann-editor-row {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 4px 0;
    font-size: 0.8rem;
}
.ann-editor-key { color: var(--reel-label); min-width: 70px; }
.ann-editor-val {
    flex: 1;
    background: var(--bg-elevated);
    border: 1px solid rgba(255,255,255,0.1);
    border-radius: 4px;
    padding: 3px 6px;
    color: var(--text-primary);
    font-family: var(--font-mono);
    font-size: 0.8rem;
}
.ann-editor-source { font-size: 0.65rem; color: var(--text-muted); min-width: 50px; text-align: right; }
.ann-editor-row.inherited .ann-editor-val {
    color: var(--text-secondary);
    font-style: italic;
    cursor: default;
}
.ann-editor-row.null-override {
    text-decoration: line-through;
    opacity: 0.5;
}
.ann-editor-row.null-override .ann-restore-btn {
    text-decoration: none;
    opacity: 1;
    cursor: pointer;
    color: var(--accent-blue);
    font-size: 0.7rem;
}
.ann-editor-actions {
    display: flex;
    gap: 8px;
    margin-top: 8px;
}
.ann-editor-btn {
    font-family: var(--font-mono);
    font-size: 0.75rem;
    padding: 3px 10px;
    border-radius: 4px;
    border: 1px solid rgba(255,255,255,0.1);
    background: var(--bg-elevated);
    color: var(--text-secondary);
    cursor: pointer;
}
.ann-editor-btn:hover { border-color: var(--reel-value); color: var(--reel-value); }

/* ── Token counter ── */
.ann-token-demo {
    margin-top: 2rem;
    padding-top: 1.5rem;
    border-top: 1px solid rgba(255,255,255,0.06);
}
.ann-subsection-title { font-size: 1.1rem; color: var(--text-primary); margin-bottom: 0.3rem; }
.ann-subsection-desc { font-size: 0.8rem; color: var(--text-secondary); margin-bottom: 1rem; }
.ann-token-block {
    display: flex;
    gap: 1rem;
    align-items: flex-start;
    margin-bottom: 0.8rem;
}
.ann-token-textarea {
    flex: 1;
    background: var(--bg-surface);
    border: 1px solid rgba(255,255,255,0.1);
    border-radius: 6px;
    padding: 0.6rem;
    color: var(--text-primary);
    font-family: var(--font-mono);
    font-size: 0.85rem;
    min-height: 60px;
    resize: vertical;
}
.ann-token-chip {
    font-size: 0.8rem;
    padding: 4px 10px;
    border-radius: 4px;
    font-family: var(--font-mono);
    white-space: nowrap;
    transition: background 0.2s, color 0.2s;
}
.ann-token-chip.ok { background: rgba(63, 185, 80, 0.12); color: var(--accent-green); }
.ann-token-chip.warn { background: rgba(255, 107, 53, 0.12); color: var(--accent-amber); }
.ann-token-chip.over { background: rgba(248, 81, 73, 0.15); color: #f85149; }
.ann-token-budget {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    font-size: 0.8rem;
    color: var(--text-secondary);
}
.ann-budget-input {
    width: 70px;
    background: var(--bg-elevated);
    border: 1px solid rgba(255,255,255,0.1);
    color: var(--text-primary);
    padding: 3px 6px;
    border-radius: 4px;
    font-family: var(--font-mono);
    font-size: 0.8rem;
}

/* ── Responsive ── */
@media (max-width: 768px) {
    /* depth-based padding set inline via JS */
    .quill-section { padding: 4rem 1rem 3rem; }
    .quill-editor-area { padding: 1rem; }
    .demo-section { padding: 3rem 1rem 2rem; }
    .ann-layers { flex-direction: column; }
    .ann-merge-arrow { transform: rotate(90deg); align-self: center; padding-top: 0; }
}
</style>
</head>
<body>

<!-- Value popover (fixed positioned) -->
<div class="wc-popover" id="wc-popover" style="display: none;" data-testid="wc-popover">
    <div class="wc-popover-name"></div>
    <div class="wc-popover-tab-landing">Press <kbd>TAB</kbd> to add values</div>
    <div class="wc-popover-form" style="display:none;">
        <div class="wc-popover-pills"></div>
        <input class="wc-popover-input" type="text" placeholder="add values, comma separated" data-testid="wc-popover-input">
    </div>
</div>

<!-- ═══════════════════════════════════════════
     SECTION 2: Quill Editor
     ═══════════════════════════════════════════ -->
<section class="quill-section" id="quill-section">
    <h2 class="quill-title">PromptyUI</h2>
    <p class="quill-subtitle">Compose. Combine. Generate.</p>

    <div class="quill-editor-area" data-testid="quill-editor-area">
        <div class="quill-blocks" id="quill-blocks"></div>
        <div class="q-add-block" id="q-add-block">Write your first prompt...</div>
    </div>

    <div class="quill-formula-area">
        <div class="demo-formula" id="quill-formula"></div>
        <div class="demo-count quill-count" id="quill-count" data-testid="quill-count"></div>
        <div class="math-label visible" id="quill-label">compositions</div>
        <button class="q-save-continue-btn" id="quill-save-btn" data-testid="quill-save-btn">Save Current and Continue</button>
    </div>
</section>

<script src="/vendor/quill/quill.js"></script>
<script>
/* ══════════════════════════════════════════════════
   DATA
   ══════════════════════════════════════════════════ */
var SEASONS = ['autumn', 'winter', 'spring', 'summer'];
var STYLES = ['watercolor', 'oil', 'digital', 'pencil'];
var BASE = 'A cabin in the forest';
var DEMO_COLORS = ['#ff6b35', '#58a6ff', '#3fb950', '#bc8cff', '#ff6b35', '#58a6ff', '#3fb950'];

/* ══════════════════════════════════════════════════
   ODOMETER
   ══════════════════════════════════════════════════ */
function rollOdometerTo(containerEl, num, prevNum) {
    var newFormatted = num.toLocaleString();
    var newRaw = num.toString().split('').map(Number);
    var oldRaw = prevNum.toString().split('').map(Number);

    while (oldRaw.length < newRaw.length) oldRaw.unshift(0);
    while (newRaw.length < oldRaw.length) newRaw.unshift(0);

    containerEl.innerHTML = '';
    var rawIdx = 0;
    var totalDigits = newRaw.length;

    newFormatted.split('').forEach(function(ch) {
        if (ch === ',') {
            var comma = document.createElement('span');
            comma.className = 'odo-comma';
            comma.textContent = ',';
            containerEl.appendChild(comma);
            return;
        }

        var target = parseInt(ch);
        var from = oldRaw[rawIdx] || 0;
        var staggerDelay = (totalDigits - 1 - rawIdx) * 80 + 20;
        rawIdx++;

        var stripEnd = 9;
        if (target < from) {
            stripEnd = 10 + target;
        }

        var wrap = document.createElement('span');
        wrap.className = 'odo-wrap';
        var strip = document.createElement('span');
        strip.className = 'odo-strip';

        for (var n = 0; n <= stripEnd; n++) {
            var d = document.createElement('span');
            d.className = 'odo-d';
            d.textContent = n % 10;
            strip.appendChild(d);
        }

        strip.style.transform = 'translateY(' + (-from) + 'em)';
        wrap.appendChild(strip);
        containerEl.appendChild(wrap);

        (function(s, t, se, dl) {
            var animTarget = (t < from) ? se : t;
            setTimeout(function() {
                s.style.transition = 'transform 1s cubic-bezier(0.22, 1, 0.36, 1)';
                s.style.transform = 'translateY(' + (-animTarget) + 'em)';
            }, dl);
        })(strip, target, stripEnd, staggerDelay);
    });
}

/* ══════════════════════════════════════════════════
   SHARED STATE
   ══════════════════════════════════════════════════ */

var popoverEl = document.getElementById('wc-popover');
var _activePopoverWc = null;

/* ── Build an interactive reel (pre-activated, clickable) ── */
function buildDemoReel(name, values) {
    var reel = document.createElement('span');
    reel.className = 'reel interactive';
    reel.setAttribute('data-wc', name);
    reel.setAttribute('data-testid', 'demo-reel-' + name);

    var label = document.createElement('span');
    label.className = 'reel-label float';
    label.textContent = name;
    reel.appendChild(label);

    var win = document.createElement('span');
    win.className = 'reel-window open';

    var track = document.createElement('span');
    track.className = 'reel-track visible';

    if (values.length === 0) {
        var placeholder = document.createElement('span');
        placeholder.className = 'reel-item placeholder';
        placeholder.textContent = '+';
        track.appendChild(placeholder);
    } else {
        values.forEach(function(v) {
            var item = document.createElement('span');
            item.className = 'reel-item';
            item.textContent = v;
            track.appendChild(item);
        });
    }

    win.appendChild(track);
    reel.appendChild(win);

    var maxLen = 0;
    values.forEach(function(v) { if (v.length > maxLen) maxLen = v.length; });
    reel.style.minWidth = Math.max(name.length + 1, (values.length === 0 ? 1 : maxLen) + 1) + 'ch';

    if (values.length > 1) {
        var badge = document.createElement('span');
        badge.className = 'reel-badge';
        badge.textContent = '+' + values.length;
        reel._badge = badge;
        reel.appendChild(badge);
    }

    reel._values = values;
    reel._name = name;
    reel._track = track;
    reel._label = label;
    reel._currentIdx = 0;

    reel.addEventListener('click', function(e) {
        e.stopPropagation();
        openPopover(reel);
    });

    return reel;
}

/* ── Rebuild a reel's track after values change ── */
function rebuildDemoReel(wcData) {
    var reel = wcData.reelEl;
    var track = reel._track;

    track.innerHTML = '';
    if (wcData.values.length === 0) {
        var placeholder = document.createElement('span');
        placeholder.className = 'reel-item placeholder';
        placeholder.textContent = '+';
        track.appendChild(placeholder);
    } else {
        wcData.values.forEach(function(v) {
            var item = document.createElement('span');
            item.className = 'reel-item';
            item.textContent = v;
            track.appendChild(item);
        });
    }

    reel._values = wcData.values;
    reel._currentIdx = 0;

    var maxLen = 0;
    wcData.values.forEach(function(v) { if (v.length > maxLen) maxLen = v.length; });
    reel.style.minWidth = Math.max(wcData.name.length + 1, (wcData.values.length === 0 ? 1 : maxLen) + 1) + 'ch';

    // Update badge count
    if (reel._badge) {
        if (wcData.values.length > 1) {
            reel._badge.textContent = '+' + wcData.values.length;
        } else {
            reel._badge.remove();
            reel._badge = null;
        }
    } else if (wcData.values.length > 1) {
        var badge = document.createElement('span');
        badge.className = 'reel-badge';
        badge.textContent = '+' + wcData.values.length;
        reel._badge = badge;
        reel.appendChild(badge);
    }

    track.style.transition = 'none';
    track.style.transform = 'translateY(0)';
}

/* ══════════════════════════════════════════════════
   POPOVER — edit wildcard values
   ══════════════════════════════════════════════════ */
var _popoverIsChip = false; // true when popover opened from an edit-mode chip
var _popoverFromClick = false; // true when popover opened by explicit click (not cursor-adjacent)

function openPopover(reelEl, fromClick) {
    var wcData = reelEl._wcRef;
    if (!wcData) return;

    if (_activePopoverWc && _activePopoverWc.reelEl) {
        _activePopoverWc.reelEl.classList.remove('popover-open');
    }

    _activePopoverWc = wcData;
    _popoverIsChip = reelEl.classList.contains('ql-wildcard-chip');
    _popoverFromClick = !!fromClick;
    reelEl.classList.add('popover-open');

    var rect = reelEl.getBoundingClientRect();
    popoverEl.style.display = 'block';

    // Measure popover dimensions
    var popW = popoverEl.offsetWidth;
    var popH = popoverEl.offsetHeight;
    var vw = window.innerWidth;
    var vh = window.innerHeight;
    var margin = 12;

    // Horizontal: align to left or right corner of the chip
    // based on which side has more room
    var chipCenterX = rect.left + rect.width / 2;
    var left;
    if (chipCenterX < vw / 2) {
        // Chip is in the left half — align popover's left edge to chip's left
        left = rect.left;
    } else {
        // Chip is in the right half — align popover's right edge to chip's right
        left = rect.right - popW;
    }
    // Clamp to viewport edges
    left = Math.max(margin, Math.min(left, vw - popW - margin));

    // Vertical: always UNDER the chip
    var top = rect.bottom + 8;
    // If it would overflow the viewport bottom, scroll it into view after positioning
    // but never flip above — always stay below
    if (top + popH > vh - margin) {
        top = Math.max(rect.bottom + 4, vh - popH - margin);
    }

    popoverEl.style.left = left + 'px';
    popoverEl.style.top = top + 'px';

    renderPopoverContent();

    // If popover extends below viewport, scroll it into view
    if (top + popH > vh) {
        popoverEl.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
    }
}

function closePopover() {
    if (_activePopoverWc && _activePopoverWc.reelEl) {
        _activePopoverWc.reelEl.classList.remove('popover-open');
    }
    popoverEl.style.display = 'none';
    _activePopoverWc = null;
}

function renderPopoverContent() {
    if (!_activePopoverWc) return;
    var wcData = _activePopoverWc;

    var nameEl = popoverEl.querySelector('.wc-popover-name');
    var pillsEl = popoverEl.querySelector('.wc-popover-pills');
    var inputEl = popoverEl.querySelector('.wc-popover-input');
    var landingEl = popoverEl.querySelector('.wc-popover-tab-landing');
    var formEl = popoverEl.querySelector('.wc-popover-form');

    nameEl.textContent = wcData.name;
    pillsEl.innerHTML = '';

    wcData.values.forEach(function(v, i) {
        var pill = document.createElement('span');
        pill.className = 'wc-pill';
        pill.setAttribute('data-testid', 'wc-pill-' + i);

        var text = document.createTextNode(v + ' ');
        pill.appendChild(text);

        if (wcData.values.length > 1) {
            var rm = document.createElement('span');
            rm.className = 'wc-pill-remove';
            rm.textContent = '\u00d7';
            rm.setAttribute('data-idx', i);
            pill.appendChild(rm);
        }

        pillsEl.appendChild(pill);
    });

    inputEl.value = '';

    // Empty chip + auto-open: show TAB landing, hide form
    if (_popoverIsChip && !_popoverFromClick && wcData.values.length === 0) {
        landingEl.style.display = '';
        formEl.style.display = 'none';
        inputEl.blur();
    } else {
        // Has values or explicit click: show form directly
        landingEl.style.display = 'none';
        formEl.style.display = '';
        if (_popoverIsChip && !_popoverFromClick) {
            inputEl.blur();
        } else {
            inputEl.focus();
        }
    }
}

// Pill remove handler (delegated)
popoverEl.querySelector('.wc-popover-pills').addEventListener('click', function(e) {
    var rm = e.target.closest('.wc-pill-remove');
    if (!rm || !_activePopoverWc) return;
    var idx = parseInt(rm.getAttribute('data-idx'));
    if (_activePopoverWc.values.length <= 1) return;
    _activePopoverWc.values.splice(idx, 1);
    // rebuildDemoReel only works on reel elements, not chip elements
    if (!_activePopoverWc.reelEl.classList.contains('ql-wildcard-chip')) {
        rebuildDemoReel(_activePopoverWc);
    }
    if (_activePopoverWc._recalcFn) _activePopoverWc._recalcFn(); else qRecalc();
    renderPopoverContent();
});

// Shared: submit popover input values
function submitPopoverInput(inputEl) {
    if (!_activePopoverWc) return;
    var raw = inputEl.value;
    var newVals = raw.split(',').map(function(s) { return s.trim(); }).filter(function(s) { return s.length > 0; });
    if (newVals.length === 0) return;

    newVals.forEach(function(v) {
        if (_activePopoverWc.values.indexOf(v) === -1) {
            _activePopoverWc.values.push(v);
        }
    });

    if (!_activePopoverWc.reelEl.classList.contains('ql-wildcard-chip')) {
        rebuildDemoReel(_activePopoverWc);
    }
    if (_activePopoverWc._recalcFn) _activePopoverWc._recalcFn(); else qRecalc();
    renderPopoverContent();
}

var _popoverEscPressed = false;

// Input handler — Enter to submit, Escape to cancel
popoverEl.querySelector('.wc-popover-input').addEventListener('keydown', function(e) {
    if (e.key === 'Enter') {
        e.preventDefault();
        submitPopoverInput(this);
        return;
    }
    if (e.key === 'Escape') {
        e.preventDefault();
        e.stopPropagation();
        _popoverEscPressed = true;
        this.value = '';
        closePopover();
        return;
    }
});

// Placeholder swap on focus/blur + Tab redirect + blur-to-submit
(function() {
    var inp = popoverEl.querySelector('.wc-popover-input');
    inp.addEventListener('blur', function() {
        if (_popoverEscPressed) {
            _popoverEscPressed = false;
            return;
        }
        // Blur submits like Enter
        if (_activePopoverWc && this.value.trim()) {
            submitPopoverInput(this);
        }
    });
    // When popover is open and Tab is pressed, reveal form or focus input
    document.addEventListener('keydown', function(e) {
        if (e.key !== 'Tab' || !_activePopoverWc) return;
        if (document.activeElement === inp) return; // already focused
        e.preventDefault();
        // If landing state is showing, reveal the form
        var landingEl = popoverEl.querySelector('.wc-popover-tab-landing');
        var formEl = popoverEl.querySelector('.wc-popover-form');
        if (landingEl.style.display !== 'none') {
            landingEl.style.display = 'none';
            formEl.style.display = '';
        }
        inp.focus();
    });
})();

// Close popover on click outside
document.addEventListener('click', function(e) {
    if (!_activePopoverWc) return;
    if (popoverEl.contains(e.target)) return;
    if (e.target.closest('.reel.interactive')) return;
    if (e.target.closest('.ql-wildcard-chip')) return;
    closePopover();
});

/* ══════════════════════════════════════════════════════════════
   QUILL EDITOR SECTION
   ══════════════════════════════════════════════════════════════ */

/* ── DemoWildcardBlot — minimal inline embed ── */
var QEmbed = Quill.import('blots/embed');

class DemoWildcardBlot extends QEmbed {
    static blotName = 'wildcard';
    static tagName = 'span';
    static className = 'ql-wildcard-chip';

    static create(value) {
        var node = super.create();
        var name = value.name || '';
        node.setAttribute('data-wildcard-name', name);
        node.setAttribute('contenteditable', 'false');

        // Label — centered (closed) or floated (open)
        var label = document.createElement('span');
        label.className = 'ql-wc-label';
        label.textContent = name;
        node.appendChild(label);

        // Value window — height:0 (closed), .open shows value
        var win = document.createElement('span');
        win.className = 'ql-wc-window';
        var track = document.createElement('span');
        track.className = 'ql-wc-track';
        win.appendChild(track);
        node.appendChild(win);

        // Stash refs for hydration
        node._label = label;
        node._window = win;
        node._track = track;
        node._badge = null;
        node._wcName = name;

        // Click → open popover with autofocus
        node.addEventListener('click', function(e) {
            e.stopPropagation();
            openChipPopover(node, true);
        });

        // Hydrate from registry on next frame (DOM must be attached first)
        requestAnimationFrame(function() { hydrateChip(node); });

        return node;
    }

    static value(node) {
        return { name: node.getAttribute('data-wildcard-name') || '' };
    }
}

Quill.register(DemoWildcardBlot);

/* ── Chip helpers — hydrate, update, popover ── */

function hydrateChip(chipNode) {
    if (!chipNode.isConnected) return;
    var name = chipNode._wcName;
    var reg = qState.chipRegistry[name];
    if (reg) {
        if (reg.chipEls.indexOf(chipNode) === -1) reg.chipEls.push(chipNode);
    }
    var values = reg ? reg.values : [];
    updateChipAppearance(chipNode, values);
}

function updateChipAppearance(chipNode, values) {
    var name = chipNode._wcName;
    var reg = qState.chipRegistry[name];
    var isEmpty = !values || values.length === 0;

    // Clean disconnected chip elements
    if (reg) {
        reg.chipEls = reg.chipEls.filter(function(el) { return el.isConnected; });
    }

    // Float label
    chipNode._label.classList.add('float');

    // Rebuild track items
    var track = chipNode._track;
    track.innerHTML = '';

    if (isEmpty) {
        var placeholder = document.createElement('span');
        placeholder.className = 'ql-wc-item placeholder';
        placeholder.textContent = '+';
        track.appendChild(placeholder);
    } else {
        // Show only the last value (most recently added)
        var lastVal = values[values.length - 1];
        var item = document.createElement('span');
        item.className = 'ql-wc-item';
        item.textContent = lastVal;
        track.appendChild(item);
    }
    track.classList.add('visible');

    // Open window
    chipNode._window.classList.add('open');

    // Compute min-width
    var maxLen = isEmpty ? 1 : 0;
    if (!isEmpty) {
        values.forEach(function(v) { if (v.length > maxLen) maxLen = v.length; });
    }
    chipNode.style.minWidth = Math.max(name.length + 1, maxLen + 1) + 'ch';

    // Badge
    if (chipNode._badge) {
        if (!isEmpty && values.length > 1) {
            chipNode._badge.textContent = '+' + values.length;
        } else {
            chipNode._badge.remove();
            chipNode._badge = null;
        }
    } else if (!isEmpty && values.length > 1) {
        var badge = document.createElement('span');
        badge.className = 'ql-wc-badge';
        badge.textContent = '+' + values.length;
        chipNode._badge = badge;
        chipNode.appendChild(badge);
    }
}

function openChipPopover(chipNode, fromClick) {
    var name = chipNode._wcName;

    // Ensure registry entry
    if (!qState.chipRegistry[name]) {
        qState.chipRegistry[name] = { values: [], color: nextQColor(), chipEls: [] };
    }
    var reg = qState.chipRegistry[name];
    if (reg.chipEls.indexOf(chipNode) === -1) reg.chipEls.push(chipNode);

    // Build a wcData-compatible object the popover can work with
    var wcData = {
        name: name,
        values: reg.values,
        color: reg.color,
        reelEl: chipNode,
        _recalcFn: function() {
            // Update all chip elements for this wildcard
            reg.chipEls = reg.chipEls.filter(function(el) { return el.isConnected; });
            reg.chipEls.forEach(function(el) { updateChipAppearance(el, reg.values); });
            // Sync into blocks so qRecalc formula is correct
            syncRegistryToBlocks();
            qRecalc();
        }
    };
    chipNode._wcRef = wcData;

    openPopover(chipNode, fromClick);
}

function syncRegistryToBlocks() {
    qState.blocks.forEach(function(block) {
        block.wildcards.forEach(function(wc) {
            var reg = qState.chipRegistry[wc.name];
            if (reg) {
                wc.values = reg.values;
                wc.color = reg.color;
            }
        });
    });
}

/* ── Quill section state ── */
var qState = {
    blocks: [],
    prevOdo: 0,
    colorIdx: 0,
    nextId: 0,
    chipRegistry: {},
    _addingChild: false,
    _lastEditedBlock: null,
    _userEdited: false,
    _recalcDirty: false
};

var qBlocksEl = document.getElementById('quill-blocks');
var qFormulaEl = document.getElementById('quill-formula');
var qCountEl = document.getElementById('quill-count');
var QDelta = Quill.import('delta');

function nextQColor() {
    var c = DEMO_COLORS[qState.colorIdx % DEMO_COLORS.length];
    qState.colorIdx++;
    return c;
}

/* ── Serialize Quill delta to plain text with __name__ patterns ── */
function serializeQuill(quill) {
    var delta = quill.getContents();
    var text = '';
    delta.ops.forEach(function(op) {
        if (typeof op.insert === 'string') {
            text += op.insert;
        } else if (op.insert && op.insert.wildcard) {
            text += '__' + op.insert.wildcard.name + '__';
        }
    });
    return text.replace(/\n$/, '');
}

/* ── Parse __name__ patterns into wildcard positions ── */
function parseQWildcards(text) {
    var regex = /__([a-zA-Z](?:[a-zA-Z0-9_-]*[a-zA-Z0-9])?)__/g;
    var match;
    var wildcards = [];
    while ((match = regex.exec(text)) !== null) {
        wildcards.push({ pos: match.index, len: match[0].length, name: match[1] });
    }
    return wildcards;
}

/* ── Convert __name__ patterns to chip embeds — FIXED: uses getContents() + posMap ──
 *
 * Bug fixed: the original used quill.getText() which silently skips embed blots,
 * so match.index was offset by N (number of embeds before the pattern). This caused
 * the delta to delete the wrong range, leaving residual __ text after the chip.
 *
 * Fix: build a text→doc position map from getContents() so each character index in
 * searchText maps to the correct document position regardless of preceding embeds.
 */
function convertQWildcards(quill) {
    var contents = quill.getContents();
    var searchText = '';
    var docPos = 0;
    var posMap = []; // posMap[textCharIdx] = documentIdx

    contents.ops.forEach(function(op) {
        if (typeof op.insert === 'string') {
            for (var i = 0; i < op.insert.length; i++) {
                posMap.push(docPos + i);
            }
            searchText += op.insert;
            docPos += op.insert.length;
        } else {
            // Embed: 1 doc position, contributes 0 chars to searchText
            docPos += 1;
        }
    });
    posMap.push(docPos); // sentinel

    var match = /__([a-zA-Z](?:[a-zA-Z0-9_-]*[a-zA-Z0-9])?)__/.exec(searchText);
    if (!match) return false;

    var docMatchStart = posMap[match.index];
    var docMatchEnd = posMap[match.index + match[0].length];

    var delta = new QDelta()
        .retain(docMatchStart)
        .delete(docMatchEnd - docMatchStart)
        .insert({ wildcard: { name: match[1] } });

    quill.updateContents(delta, 'silent');

    // If the new chip is now the last element before \n, add ZWSP so the
    // browser has a real text node to anchor the caret (avoids top-right bug)
    if (docMatchStart + 1 === quill.getLength() - 1) {
        quill.updateContents(new QDelta().retain(docMatchStart + 1).insert('\u200B'), 'silent');
    }

    quill.setSelection(docMatchStart + 1, 0, 'silent');

    // Auto-open popover for newly typed chip (if it has no values yet)
    var newName = match[1];
    requestAnimationFrame(function() {
        var chip = quill.root.querySelector('.ql-wildcard-chip[data-wildcard-name="' + newName + '"]');
        if (chip && (!qState.chipRegistry[newName] || qState.chipRegistry[newName].values.length === 0)) {
            openChipPopover(chip);
        }
    });

    return true;
}

/* ── Recalculate formula + odometer for Quill section ── */
function qRecalc() {
    // Defer recalc while editing — flush when idle (clearEditFocus)
    if (document.querySelector('.q-block.editing')) {
        qState._recalcDirty = true;
        return;
    }
    qState._recalcDirty = false;

    qFormulaEl.innerHTML = '';
    var total = 1;
    var terms = []; // { label, count, color }

    // ── Count total leaves across all root subtrees ──
    // A "leaf" is a terminal block (no children). Multiple roots are additive:
    // root1(2 leaves) + root2(1 leaf) = 3 total leaves.
    // Children under a parent create separate text variations (parent+child1, parent+child2).
    var roots = qState.blocks.filter(function(b) { return b.depth === 0; });
    var totalLeaves = 0;
    roots.forEach(function(root) {
        totalLeaves += countLeaves(root);
    });
    if (totalLeaves > 1) {
        terms.push({ label: 'lines', count: totalLeaves, color: 'var(--text-secondary)' });
    }

    // ── Collect unique wildcards across all blocks ──
    var seen = {};
    qState.blocks.forEach(function(block) {
        block.wildcards.forEach(function(wc) {
            if (wc.values.length === 0) return;
            if (seen[wc.name]) return; // deduplicate same wildcard across blocks
            seen[wc.name] = true;
            terms.push({ label: wc.name, count: wc.values.length, color: wc.color });
        });
    });

    // ── Build formula display ──
    terms.forEach(function(t, i) {
        if (i > 0) {
            var x = document.createElement('span');
            x.className = 'formula-x';
            x.textContent = '\u00d7';
            qFormulaEl.appendChild(x);
        }
        var term = document.createElement('span');
        term.className = 'formula-term';
        term.style.color = t.color;
        term.innerHTML = t.label + '<span class="formula-count">(' + t.count + ')</span>';
        qFormulaEl.appendChild(term);
        total *= t.count;
    });

    var prev = qState.prevOdo;
    qState.prevOdo = total;
    rollOdometerTo(qCountEl, total, prev);
}

/* ── Count leaf nodes in a block's subtree ── */
function countLeaves(block) {
    var children = getChildrenOf(block);
    if (children.length === 0) return 1; // terminal block = 1 leaf
    var total = 0;
    children.forEach(function(child) {
        total += countLeaves(child);
    });
    return total;
}

/* ── Update tree connectors for Quill blocks ── */
function updateQConnectors() {
    // For each block, find its direct children and set connectors
    for (var i = 0; i < qState.blocks.length; i++) {
        var parent = qState.blocks[i];
        var directChildren = getChildrenOf(parent);
        directChildren.forEach(function(b, ci) {
            var text = (ci < directChildren.length - 1) ? '\u251C\u2500\u2500 ' : '\u2514\u2500\u2500 ';
            if (b._connector) b._connector.textContent = text;
            if (b._editConnector) b._editConnector.textContent = text;
        });
    }
}

/* ── Build view mode content for a block ── */
function buildBlockView(block) {
    var viewEl = block.viewEl;
    viewEl.innerHTML = '';

    // Set depth-based indentation on view
    if (block.depth > 0) {
        viewEl.style.paddingLeft = (block.depth * 2) + 'ch';
        var conn = document.createElement('span');
        conn.className = 'tree-connector';
        conn.textContent = '\u2514\u2500\u2500 ';
        block._connector = conn;
        viewEl.appendChild(conn);
    } else {
        viewEl.style.paddingLeft = '';
    }

    var serialized = serializeQuill(block.quill);
    var wcDefs = parseQWildcards(serialized);

    var prevMap = {};
    if (block._prevWildcards) {
        block._prevWildcards.forEach(function(pw) { prevMap[pw.name] = pw; });
    }

    block.wildcards = [];

    if (wcDefs.length === 0) {
        viewEl.appendChild(document.createTextNode(serialized));
    } else {
        var cursor = 0;
        wcDefs.forEach(function(wc) {
            var before = serialized.slice(cursor, wc.pos);
            if (before) viewEl.appendChild(document.createTextNode(before));

            var prev = prevMap[wc.name];
            var reg = qState.chipRegistry[wc.name];
            var values = prev ? prev.values.slice() : (reg ? reg.values.slice() : [wc.name]);
            var color = prev ? prev.color : (reg ? reg.color : nextQColor());

            var reel = buildDemoReel(wc.name, values);
            var wcData = {
                name: wc.name,
                values: values,
                color: color,
                reelEl: reel,
                _recalcFn: qRecalc
            };
            reel._wcRef = wcData;
            viewEl.appendChild(reel);
            block.wildcards.push(wcData);

            // Sync registry so chips in edit mode stay current
            if (!qState.chipRegistry[wc.name]) {
                qState.chipRegistry[wc.name] = { values: values, color: color, chipEls: [] };
            } else {
                qState.chipRegistry[wc.name].values = values;
                qState.chipRegistry[wc.name].color = color;
            }

            cursor = wc.pos + wc.len;
        });

        var remaining = serialized.slice(cursor);
        if (remaining) viewEl.appendChild(document.createTextNode(remaining));
    }

    updateQConnectors();
    // Only update composition when block has content (skip empty/uncommitted blocks)
    if (serialized) qRecalc();
}

/* ── Create a Quill-backed block ── */
function createQBlock(initialText, depth, wildcardValues, placeholder) {
    var id = qState.nextId++;
    if (typeof depth === 'boolean') depth = depth ? 1 : 0; // backwards compat

    var blockEl = document.createElement('div');
    blockEl.className = 'q-block' + (depth > 0 ? ' q-block--child' : '');
    blockEl.setAttribute('data-block-id', id);
    blockEl.setAttribute('data-depth', depth);

    var viewEl = document.createElement('div');
    viewEl.className = 'q-block-view editor-line' + (depth > 0 ? ' editor-line--child visible' : '');
    if (depth > 0) viewEl.style.paddingLeft = (depth * 2) + 'ch';
    blockEl.appendChild(viewEl);

    var editEl = document.createElement('div');
    editEl.className = 'q-block-edit';

    var editConn = null;
    if (depth > 0) {
        editConn = document.createElement('span');
        editConn.className = 'q-edit-connector';
        editConn.style.paddingLeft = (depth * 2) + 'ch';
        editConn.textContent = '\u2514\u2500\u2500 ';
        editEl.appendChild(editConn);
    }

    var quillContainer = document.createElement('div');
    quillContainer.className = 'q-quill-wrap';
    editEl.appendChild(quillContainer);

    // Action buttons on the gradient border
    var actionsBar = document.createElement('div');
    actionsBar.className = 'q-block-actions';
    if (initialText.replace(/\u200B/g, '').trim()) actionsBar.classList.add('visible');

    var actionDefs = [
        { label: '\u21B5 New', hint: 'Ctrl+\u21B5', fn: 'sibling' },
        { label: '\u21B3 Nest', hint: 'Tab', fn: 'child' },
        { label: '\u2295 Copy', hint: '\u2318D', fn: 'duplicate' }
    ];
    actionDefs.forEach(function(def) {
        var btn = document.createElement('span');
        btn.className = 'q-block-action';
        btn.setAttribute('data-action', def.fn);
        btn.innerHTML = '<span class="q-action-hint">' + def.hint + '</span>' + def.label;
        actionsBar.appendChild(btn);
    });
    editEl.appendChild(actionsBar);

    // Floating inline hint (positioned relative to editEl)
    var inlineHint = document.createElement('div');
    inlineHint.className = 'q-inline-hint';
    editEl.appendChild(inlineHint);

    blockEl.appendChild(editEl);

    var quill = new Quill(quillContainer, {
        theme: 'snow',
        modules: { toolbar: false },
        placeholder: placeholder || ''
    });

    var wcParsed = parseQWildcards(initialText);
    if (wcParsed.length > 0) {
        var ops = [];
        var cursor = 0;
        wcParsed.forEach(function(wc) {
            if (wc.pos > cursor) ops.push({ insert: initialText.slice(cursor, wc.pos) });
            ops.push({ insert: { wildcard: { name: wc.name } } });
            cursor = wc.pos + wc.len;
        });
        var rem = initialText.slice(cursor);
        if (rem) ops.push({ insert: rem });
        // Ensure trailing text node so browser can anchor caret after last embed
        else ops.push({ insert: '\u200B' });
        ops.push({ insert: '\n' });
        quill.setContents(ops, 'silent');
    } else {
        quill.setText(initialText, 'silent');
    }

    // ── Inline hint positioning ──
    function showInlineHint(html, anchorEl) {
        inlineHint.innerHTML = html;
        // Position below the anchor element
        var editRect = editEl.getBoundingClientRect();
        var anchorRect = anchorEl.getBoundingClientRect();
        inlineHint.style.left = (anchorRect.left - editRect.left) + 'px';
        inlineHint.style.top = (anchorRect.bottom - editRect.top + 4) + 'px';
        inlineHint.classList.add('visible');
    }
    function hideInlineHint() {
        inlineHint.classList.remove('visible');
    }

    // ── Detect __ prefix for wildcard completion hint ──
    function checkDoubleUnderscoreHint() {
        var range = quill.getSelection();
        if (!range || range.length !== 0) { hideInlineHint(); return false; }
        var idx = range.index;

        // Build plain text up to cursor (skipping embeds)
        var contents = quill.getContents();
        var textBefore = '';
        var charCount = 0;
        for (var i = 0; i < contents.ops.length; i++) {
            var op = contents.ops[i];
            if (typeof op.insert === 'string') {
                var remaining = idx - charCount;
                if (remaining <= op.insert.length) {
                    textBefore += op.insert.slice(0, remaining);
                    break;
                }
                textBefore += op.insert;
                charCount += op.insert.length;
            } else {
                charCount += 1; // embed
            }
        }

        // Check if text before cursor ends with __ but isn't a complete __name__ pattern
        if (textBefore.length >= 2 && textBefore.slice(-2) === '__') {
            // Make sure it's not the closing __ of a complete pattern
            var prefix = textBefore.slice(0, -2);
            if (!/__([\w-]+)$/.test(prefix)) {
                // Show hint at cursor position
                var cursorBounds = quill.getBounds(idx);
                var fakeAnchor = { getBoundingClientRect: function() {
                    var er = editEl.getBoundingClientRect();
                    return { left: er.left + cursorBounds.left, right: er.left + cursorBounds.left + 1,
                             top: er.top + cursorBounds.top, bottom: er.top + cursorBounds.bottom };
                }};
                showInlineHint('<span class="hint-dim">wrap with</span> __wildcard__', fakeAnchor);
                return true;
            }
        }
        return false;
    }

    quill.on('text-change', function(delta, oldDelta, source) {
        if (source !== 'user') return;
        convertQWildcards(quill);
        // Toggle actions bar visibility based on content
        var text = serializeQuill(quill).replace(/\u200B/g, '').trim();
        if (text) actionsBar.classList.add('visible');
        else actionsBar.classList.remove('visible');
        // Check for __ hint after text changes
        requestAnimationFrame(function() { checkDoubleUnderscoreHint(); });
    });

    // Show popover when cursor lands adjacent to a wildcard chip
    quill.on('selection-change', function(range, oldRange, source) {
        if (!range || range.length !== 0) { hideInlineHint(); return; }
        if (source !== 'user') return;
        var idx = range.index;

        // Check leaf at cursor (right side: cursor|wildcard) and
        // leaf before cursor (left side: wildcard|cursor) — only if immediately adjacent
        var chipNode = null;
        var leafAt = quill.getLeaf(idx);
        if (leafAt && leafAt[0] && leafAt[0].constructor.blotName === 'wildcard') {
            chipNode = leafAt[0].domNode;
        }
        if (!chipNode && idx > 0) {
            var leafBefore = quill.getLeaf(idx - 1);
            if (leafBefore && leafBefore[0] && leafBefore[0].constructor.blotName === 'wildcard') {
                // Verify cursor is immediately after the wildcard (blotPos + 1 === idx)
                var blotPos = quill.getIndex(leafBefore[0]);
                if (blotPos + 1 === idx) {
                    chipNode = leafBefore[0].domNode;
                }
            }
        }

        if (chipNode) {
            // Only open if not already showing this chip's popover
            if (!_activePopoverWc || _activePopoverWc.reelEl !== chipNode) {
                openChipPopover(chipNode);
            }
            hideInlineHint();
        } else {
            if (_popoverIsChip) {
                // Cursor moved away from any wildcard — close chip popover
                closePopover();
            }
            // Check for __ hint when cursor moves
            if (!checkDoubleUnderscoreHint()) {
                hideInlineHint();
            }
        }
    });

    var block = {
        id: id,
        depth: depth,
        get isChild() { return this.depth > 0; },
        lineEl: blockEl,
        viewEl: viewEl,
        editEl: editEl,
        quill: quill,
        wildcards: [],
        _prevWildcards: null,
        _connector: null,
        _editConnector: editConn
    };

    if (wildcardValues) {
        block._prevWildcards = Object.keys(wildcardValues).map(function(name) {
            var color = nextQColor();
            var vals = wildcardValues[name].slice();
            // Populate chipRegistry so hydrateChip can read values immediately
            if (!qState.chipRegistry[name]) {
                qState.chipRegistry[name] = { values: vals, color: color, chipEls: [] };
            } else {
                qState.chipRegistry[name].values = vals;
                qState.chipRegistry[name].color = color;
            }
            return { name: name, values: vals, color: color };
        });
    }

    viewEl.addEventListener('click', function(e) {
        if (e.target.closest('.reel.interactive')) return;
        switchToEdit(block);
    });

    // Action dispatch for actions bar buttons
    function actionDispatch(actionName, b) {
        var text = serializeQuill(b.quill).replace(/\u200B/g, '').trim();
        if (!text) return;
        if (actionName === 'sibling') addSiblingBlock(b);
        else if (actionName === 'child') addChildBlock(b);
        else if (actionName === 'duplicate') duplicateBlock(b);
    }

    // Prevent mousedown on actions bar from blurring the Quill editor
    actionsBar.addEventListener('mousedown', function(e) { e.preventDefault(); e.stopPropagation(); });
    actionsBar.addEventListener('touchstart', function(e) { e.preventDefault(); e.stopPropagation(); }, { passive: false });
    actionsBar.addEventListener('touchend', function(e) {
        e.preventDefault(); e.stopPropagation();
        var btn = e.target.closest('.q-block-action');
        if (btn) actionDispatch(btn.getAttribute('data-action'), block);
    });
    actionsBar.addEventListener('click', function(e) {
        e.stopPropagation();
        var btn = e.target.closest('.q-block-action');
        if (btn) actionDispatch(btn.getAttribute('data-action'), block);
    });

    qState.blocks.push(block);
    buildBlockView(block);
    return block;
}

/* ── Find the parent block for a given block (nearest shallower block above) ── */
function findParentBlock(block) {
    var idx = qState.blocks.indexOf(block);
    if (idx <= 0 || block.depth === 0) return null;
    for (var p = idx - 1; p >= 0; p--) {
        if (qState.blocks[p].depth < block.depth) return qState.blocks[p];
    }
    return null;
}

/* ── Find direct children of a given block ── */
function getChildrenOf(parentBlock) {
    var parentIdx = qState.blocks.indexOf(parentBlock);
    var children = [];
    for (var i = parentIdx + 1; i < qState.blocks.length; i++) {
        if (qState.blocks[i].depth <= parentBlock.depth) break; // hit sibling or higher
        if (qState.blocks[i].depth === parentBlock.depth + 1) {
            children.push(qState.blocks[i]);
        }
    }
    return children;
}

/* ── Get the full ancestor chain of a block (bottom-up) ── */
function getAncestors(block) {
    var ancestors = [];
    var current = block;
    while (current && current.depth > 0) {
        var parent = findParentBlock(current);
        if (parent) ancestors.push(parent);
        current = parent;
    }
    return ancestors;
}

/* ── Find index after last descendant of a block (for sibling insertion) ── */
function findSubtreeEnd(block) {
    var idx = qState.blocks.indexOf(block);
    var end = idx + 1;
    while (end < qState.blocks.length && qState.blocks[end].depth > block.depth) {
        end++;
    }
    return end;
}

/* ── Shared helper: finish source edit and insert new block ── */
function _finishAndInsert(sourceBlock, insertIdx, newDepth, wildcardValues, placeholder) {
    qState._addingChild = true;
    qState._lastEditedBlock = sourceBlock;
    syncRegistryToBlocks();
    sourceBlock._prevWildcards = sourceBlock.wildcards.slice();
    sourceBlock.lineEl.classList.remove('editing');
    clearEditFocus();
    buildBlockView(sourceBlock);

    var newBlock = createQBlock('', newDepth, wildcardValues, placeholder);
    // Remove from default append position
    var pushIdx = qState.blocks.indexOf(newBlock);
    if (pushIdx !== -1) qState.blocks.splice(pushIdx, 1);
    if (newBlock.lineEl.parentNode) newBlock.lineEl.parentNode.removeChild(newBlock.lineEl);
    // Insert at correct position
    var refBlock = qState.blocks[insertIdx];
    if (refBlock) qBlocksEl.insertBefore(newBlock.lineEl, refBlock.lineEl);
    else qBlocksEl.appendChild(newBlock.lineEl);
    qState.blocks.splice(insertIdx, 0, newBlock);
    updateQConnectors();
    requestAnimationFrame(function() {
        qState._addingChild = false;
        switchToEdit(newBlock);
    });
}

/* ── Add sibling block at same depth, after subtree ── */
function addSiblingBlock(sourceBlock) {
    var text = serializeQuill(sourceBlock.quill).replace(/\u200B/g, '').trim();
    if (!text) return;
    var ph = sourceBlock.depth === 0 ? 'Another prompt...' : 'Another variation...';
    _finishAndInsert(sourceBlock, findSubtreeEnd(sourceBlock), sourceBlock.depth, null, ph);
}

/* ── Add child block at depth+1, right after source ── */
function addChildBlock(sourceBlock) {
    var text = serializeQuill(sourceBlock.quill).replace(/\u200B/g, '').trim();
    if (!text) return;
    _finishAndInsert(sourceBlock, qState.blocks.indexOf(sourceBlock) + 1, sourceBlock.depth + 1, null, 'Add a variation...');
}

/* ── Duplicate block (copy wildcards, clear text) at same depth ── */
function duplicateBlock(sourceBlock) {
    var text = serializeQuill(sourceBlock.quill).replace(/\u200B/g, '').trim();
    if (!text) return;
    var wv = null;
    if (sourceBlock.wildcards.length > 0) {
        wv = {};
        sourceBlock.wildcards.forEach(function(wc) { wv[wc.name] = wc.values.slice(); });
    }
    _finishAndInsert(sourceBlock, findSubtreeEnd(sourceBlock), sourceBlock.depth, wv, 'Edit this copy...');
}

/* ── Highlight connectors for active block + its ancestors, clear rest ── */
function highlightConnectors(activeBlock) {
    var ancestorIds = {};
    if (activeBlock) {
        ancestorIds[activeBlock.id] = true;
        getAncestors(activeBlock).forEach(function(a) { ancestorIds[a.id] = true; });
    }
    qState.blocks.forEach(function(b) {
        var on = !!ancestorIds[b.id];
        if (b._connector) b._connector.classList.toggle('tree-active', on);
        if (b._editConnector) b._editConnector.classList.toggle('tree-active', on);
    });
}

/* ── Tree isolation focus — ancestors, descendants, siblings, and prior block visible, rest hidden ── */
function applyEditFocus(activeBlock) {
    var ancestors = getAncestors(activeBlock);
    var ancestorIds = {};
    ancestors.forEach(function(a) { ancestorIds[a.id] = true; });
    // All descendants (children, grandchildren, etc.) via subtree range
    var activeIdx = qState.blocks.indexOf(activeBlock);
    var subtreeEnd = findSubtreeEnd(activeBlock);
    var descendantIds = {};
    for (var d = activeIdx + 1; d < subtreeEnd; d++) {
        descendantIds[qState.blocks[d].id] = true;
    }
    // Siblings: other children of the same parent (faded, not hidden)
    var parent = findParentBlock(activeBlock);
    var siblingIds = {};
    if (parent) {
        getChildrenOf(parent).forEach(function(s) {
            if (s !== activeBlock) siblingIds[s.id] = true;
        });
    }
    var priorBlock = qState._lastEditedBlock;

    qState.blocks.forEach(function(b) {
        b.lineEl.classList.remove('tree-hidden');

        if (b === activeBlock) {
            b.lineEl.style.opacity = '';
        } else if (ancestorIds[b.id]) {
            b.lineEl.style.opacity = '0.9';
        } else {
            b.lineEl.style.opacity = '0.4';
        }
    });

    highlightConnectors(activeBlock);

    var addBtn = document.getElementById('q-add-block');
    if (addBtn) addBtn.style.display = 'none';
}

function clearEditFocus() {
    qState.blocks.forEach(function(b) {
        b.lineEl.style.opacity = '';
        b.lineEl.classList.remove('tree-hidden');
    });

    highlightConnectors(null);

    var addBtn = document.getElementById('q-add-block');
    if (addBtn) {
        addBtn.style.display = '';
        if (!qState._userEdited) {
            qState._userEdited = true;
            addBtn.textContent = '+ click to write another prompt';
        }
    }

    // Flush deferred recalc now that we're idle
    if (qState._recalcDirty) qRecalc();
}

/* ── Switch block to edit mode ── */
function switchToEdit(block, opts) {
    var skipIsolation = opts && opts.skipIsolation;
    closePopover();
    // Immediately finish any previously-editing block (prevents blur race)
    var prev = qState.blocks.find(function(b) { return b !== block && b.lineEl.classList.contains('editing'); });
    if (prev) {
        qState._lastEditedBlock = prev;
        syncRegistryToBlocks();
        var prevText = serializeQuill(prev.quill).replace(/\u200B/g, '').trim();
        if (!prevText) {
            prev.lineEl.remove();
            var idx = qState.blocks.indexOf(prev);
            if (idx !== -1) qState.blocks.splice(idx, 1);
            updateQConnectors();
            qRecalc();
        } else {
            prev._prevWildcards = prev.wildcards.slice();
            prev.lineEl.classList.remove('editing');
            buildBlockView(prev);
        }
    }
    block.lineEl.classList.add('editing');
    var hasChildren = getChildrenOf(block).length > 0;
    if (!skipIsolation && hasChildren) {
        applyEditFocus(block);
    } else {
        // Light fade: dim all other blocks to 0.4, no tree-hidden
        qState.blocks.forEach(function(b) {
            b.lineEl.classList.remove('tree-hidden');
            b.lineEl.style.opacity = (b === block) ? '' : '0.4';
        });
        highlightConnectors(block);
        var ab = document.getElementById('q-add-block');
        if (ab) ab.style.display = 'none';
    }
    block.quill.focus();
    var cursorPos = (opts && opts.cursorAt === 'start') ? 0 : block.quill.getLength() - 1;
    block.quill.setSelection(cursorPos, 0);

    function finishEdit() {
        if (!block.lineEl.classList.contains('editing')) return;
        syncRegistryToBlocks();
        var serialized = serializeQuill(block.quill).replace(/\u200B/g, '').trim();
        if (!serialized) {
            // Empty block — remove it
            block.lineEl.remove();
            var idx = qState.blocks.indexOf(block);
            if (idx !== -1) qState.blocks.splice(idx, 1);
            updateQConnectors();
            // Only clear isolation if no other block took over editing
            if (!document.querySelector('.q-block.editing')) clearEditFocus();
            qRecalc();
            return;
        }
        block._prevWildcards = block.wildcards.slice();
        block.lineEl.classList.remove('editing');
        buildBlockView(block);
        // Only clear isolation if no other block took over editing
        if (!document.querySelector('.q-block.editing')) clearEditFocus();
    }

    var keyHandler = function(e) {
        if (e.key === 'Enter' && (e.ctrlKey || e.metaKey)) {
            e.preventDefault(); cleanup(); addSiblingBlock(block); return;
        }
        if (e.key === 'Tab' && !e.ctrlKey && !e.metaKey && !e.shiftKey && !e.altKey) {
            e.preventDefault();
            // If popover is open, reveal form and focus its input instead of nesting
            if (_activePopoverWc) {
                var landingEl = popoverEl.querySelector('.wc-popover-tab-landing');
                var formEl = popoverEl.querySelector('.wc-popover-form');
                if (landingEl.style.display !== 'none') {
                    landingEl.style.display = 'none';
                    formEl.style.display = '';
                }
                var popInput = popoverEl.querySelector('.wc-popover-input');
                if (popInput) popInput.focus();
                return;
            }
            cleanup(); addChildBlock(block); return;
        }
        if (e.key === 'd' && (e.ctrlKey || e.metaKey) && e.shiftKey) {
            e.preventDefault(); cleanup(); duplicateBlock(block); return;
        }
        if (e.key === 'Escape') { cleanup(); finishEdit(); }

        // Arrow navigation between blocks
        var sel = block.quill.getSelection();
        if (!sel) return;
        var idx = qState.blocks.indexOf(block);

        // Up Arrow at position 0 — previous visible block, cursor at end
        if (e.key === 'ArrowUp' && sel.index === 0 && sel.length === 0) {
            if (idx > 0) {
                e.preventDefault();
                var target = qState.blocks[idx - 1];
                cleanup(); switchToEdit(target, { cursorAt: 'end' });
            }
            return;
        }
        // Down Arrow at end — next visible block, cursor at start
        if (e.key === 'ArrowDown' && sel.index >= block.quill.getLength() - 1 && sel.length === 0) {
            if (idx < qState.blocks.length - 1) {
                e.preventDefault();
                var target = qState.blocks[idx + 1];
                cleanup(); switchToEdit(target, { cursorAt: 'start' });
            }
            return;
        }
        // Left Arrow at position 0 — move to parent block
        if (e.key === 'ArrowLeft' && sel.index === 0 && sel.length === 0) {
            var parent = findParentBlock(block);
            if (parent) {
                e.preventDefault();
                cleanup(); switchToEdit(parent, { cursorAt: 'end' });
            }
            return;
        }
        // Right Arrow at end — move to first child block
        if (e.key === 'ArrowRight' && sel.index >= block.quill.getLength() - 1 && sel.length === 0) {
            var children = getChildrenOf(block);
            if (children.length > 0) {
                e.preventDefault();
                cleanup(); switchToEdit(children[0], { cursorAt: 'start' });
            }
            return;
        }
    };
    var blurHandler = function() {
        setTimeout(function() {
            if (_activePopoverWc) return; // popover open — don't finish edit
            if (qState._addingChild) return; // adding child — don't finish edit
            if (block.lineEl.classList.contains('editing')) { cleanup(); finishEdit(); }
        }, 200);
    };
    function cleanup() {
        block.quill.root.removeEventListener('keydown', keyHandler);
        block.quill.root.removeEventListener('blur', blurHandler);
    }
    block.quill.root.addEventListener('keydown', keyHandler);
    block.quill.root.addEventListener('blur', blurHandler);
}

/* ── Initialize Quill section ── */
function initQuillSection() {
    var parentBlock = createQBlock(
        BASE + ', __season__, __style__',
        false,
        { season: SEASONS.slice(), style: STYLES.slice() }
    );
    qBlocksEl.appendChild(parentBlock.lineEl);

    var childBlock = createQBlock(
        'with __detail__ level of detail',
        true,
        { detail: ['high', 'medium', 'sketch'] }
    );
    qBlocksEl.appendChild(childBlock.lineEl);

    var addBlockBtn = document.getElementById('q-add-block');
    addBlockBtn.addEventListener('click', function() {
        addBlockBtn.style.display = 'none';
        var newBlock = createQBlock('', 0, null, 'Write a prompt...');
        qBlocksEl.appendChild(newBlock.lineEl);
        updateQConnectors();
        switchToEdit(newBlock, { skipIsolation: true });
    });
}

/* ══════════════════════════════════════════════════
   START
   ══════════════════════════════════════════════════ */
initQuillSection();
</script>

<!-- ═══════════════════════════════════════════
     SECTION 3: Navigating Compositions
     ═══════════════════════════════════════════ -->
<section class="demo-section" id="preview-section" style="display: none;">
    <h2 class="demo-section-title">Navigating Compositions</h2>
    <p class="demo-section-subtitle">Explore the Cartesian product — flat browsing or bucketed windows</p>

    <!-- ── Phase 1: Flat navigator (matches live app Quick Build) ── -->
    <div class="preview-area" data-testid="preview-area">
        <div class="preview-nav" data-testid="preview-nav">
            <button class="preview-nav-btn" data-testid="preview-prev-btn" onclick="demoPreviewPrev()">&lsaquo;</button>
            <span class="preview-nav-label" data-testid="preview-nav-label">1 / 48</span>
            <button class="preview-nav-btn" data-testid="preview-next-btn" onclick="demoPreviewNext()">&rsaquo;</button>
            <button class="preview-nav-btn shuffle" data-testid="preview-shuffle-btn" onclick="demoPreviewShuffle()" title="Random composition">&#8635;</button>
        </div>

        <!-- Shared resolved text area -->
        <div class="preview-resolved" data-testid="preview-resolved"></div>

        <!-- Wildcard tags: name="value" -->
        <div class="preview-pills" data-testid="preview-pills"></div>

        <!-- Decomposition breakdown -->
        <div class="preview-breakdown" data-testid="preview-breakdown"></div>
    </div>

    <!-- ── Phase 2: Scale it up — bucketed navigation ── -->
    <div class="scale-divider" data-testid="scale-divider">When the space gets large...</div>

    <div id="bucket-area" data-testid="bucket-area">
        <!-- Window size slider -->
        <div class="bucket-control" data-testid="bucket-control">
            <label class="bucket-label">Window size (wildcards_max):</label>
            <input type="range" min="1" max="6" value="2" class="bucket-slider"
                   data-testid="bucket-slider" oninput="demoBucketSliderChanged(this.value)">
            <span class="bucket-slider-value" data-testid="bucket-slider-value">2</span>
        </div>

        <!-- Bucket visualization -->
        <div class="bucket-visual" data-testid="bucket-visual"></div>

        <!-- Bucket navigator: coarse + fine -->
        <div class="bucket-nav" data-testid="bucket-nav">
            <div class="bucket-nav-coarse" data-testid="bucket-nav-coarse">
                <span class="bucket-nav-label">Bucket:</span>
                <button class="preview-nav-btn" onclick="demoBucketPrev()">&lsaquo;</button>
                <span data-testid="bucket-coarse-label">1 / 3</span>
                <button class="preview-nav-btn" onclick="demoBucketNext()">&rsaquo;</button>
            </div>
            <div class="bucket-nav-fine" data-testid="bucket-nav-fine">
                <span class="bucket-nav-label">Within bucket:</span>
            </div>
        </div>

        <!-- Bucket resolved text (reuses shared area when active) -->
        <div class="preview-resolved" data-testid="bucket-resolved"></div>
    </div>

    <button class="q-save-continue-btn" id="preview-continue-btn" data-testid="preview-continue-btn">Continue to Annotations</button>
</section>

<!-- ═══════════════════════════════════════════
     SECTION 5: Annotations
     ═══════════════════════════════════════════ -->
<section class="demo-section" id="ann-section" style="display: none;">
    <h2 class="demo-section-title">Annotations</h2>
    <p class="demo-section-subtitle">Layer metadata on blocks — defaults, prompt-level, and block-level</p>

    <!-- Inheritance visual (3 layers merging) -->
    <div class="ann-layers" data-testid="ann-layers">
        <div class="ann-layer" data-testid="ann-layer-defaults">
            <div class="ann-layer-header">defaults</div>
            <div class="ann-layer-body" id="ann-defaults-body"></div>
        </div>
        <div class="ann-merge-arrow">&rarr;</div>
        <div class="ann-layer" data-testid="ann-layer-prompt">
            <div class="ann-layer-header">prompt</div>
            <div class="ann-layer-body" id="ann-prompt-body"></div>
        </div>
        <div class="ann-merge-arrow">&rarr;</div>
        <div class="ann-layer" data-testid="ann-layer-block">
            <div class="ann-layer-header">block</div>
            <div class="ann-layer-body" id="ann-block-body"></div>
        </div>
        <div class="ann-merge-arrow">=</div>
        <div class="ann-layer ann-layer-resolved" data-testid="ann-layer-resolved">
            <div class="ann-layer-header">resolved</div>
            <div class="ann-layer-body" id="ann-resolved-body"></div>
        </div>
    </div>

    <!-- Interactive block cards with badges -->
    <div class="ann-blocks" data-testid="ann-blocks"></div>

    <!-- Token counter demo -->
    <div class="ann-token-demo" data-testid="ann-token-demo">
        <h3 class="ann-subsection-title">Token Counter</h3>
        <p class="ann-subsection-desc">Set a budget, watch the counter update as text changes</p>
        <div class="ann-token-block" data-testid="ann-token-block">
            <textarea class="ann-token-textarea" data-testid="ann-token-textarea"
                      oninput="demoTokenUpdate(this.value)"
                      placeholder="Type text to see token count...">A cabin in the forest, autumn, watercolor</textarea>
            <div class="ann-token-chip" data-testid="ann-token-chip">~10/500</div>
        </div>
        <div class="ann-token-budget" data-testid="ann-token-budget">
            <label>Budget: </label>
            <input type="number" value="500" min="10" max="10000"
                   class="ann-budget-input" data-testid="ann-budget-input"
                   oninput="demoTokenBudgetChanged(this.value)">
            <span>tokens</span>
        </div>
    </div>
</section>

<script>
/* ══════════════════════════════════════════════════
   SECTION 3: Navigating Compositions
   ══════════════════════════════════════════════════ */

var demoPreviewState = { compId: 0, total: 0, blocks: [], wildcards: {} };

/** Port of preview.js:compositionToIndices — odometer decomposition */
function demoCompositionToIndices(compId, wcCounts) {
    var sorted = Object.keys(wcCounts).sort();
    var dimensions = sorted.map(function(n) { return Math.max(1, wcCounts[n]); });
    var total = dimensions.reduce(function(a, b) { return a * b; }, 1);
    var idx = total > 0 ? compId % total : 0;
    var indices = {};
    for (var i = sorted.length - 1; i >= 0; i--) {
        indices[sorted[i]] = idx % dimensions[i];
        idx = Math.floor(idx / dimensions[i]);
    }
    return indices;
}

/** Resolve block text by replacing __wc__ with values[index] */
function demoResolveBlock(text, wildcards, indices) {
    var resolved = text;
    Object.keys(wildcards).forEach(function(name) {
        var wc = wildcards[name];
        var idx = indices[name] || 0;
        var val = wc.values[idx] || wc.values[0] || name;
        resolved = resolved.split('__' + name + '__').join(val);
    });
    return resolved;
}

/** Render the current flat composition (Phase 1) */
function demoPreviewRender() {
    var st = demoPreviewState;
    var wcCounts = {};
    Object.keys(st.wildcards).forEach(function(n) { wcCounts[n] = st.wildcards[n].values.length; });
    var indices = demoCompositionToIndices(st.compId, wcCounts);

    // Update nav label — matches live app "N / Total" format
    document.querySelector('[data-testid="preview-nav-label"]').textContent =
        (st.compId + 1) + ' / ' + st.total;

    // Resolved text
    var resolvedEl = document.querySelector('[data-testid="preview-resolved"]');
    resolvedEl.innerHTML = '';
    st.blocks.forEach(function(block, i) {
        var div = document.createElement('div');
        div.className = 'preview-block' + (block.depth > 0 ? ' preview-block-child' : '');
        div.setAttribute('data-testid', 'preview-block-' + i);
        div.textContent = demoResolveBlock(block.text, st.wildcards, indices);
        resolvedEl.appendChild(div);
    });

    // Wildcard tags — matches live app name="value" format
    var pillsEl = document.querySelector('[data-testid="preview-pills"]');
    pillsEl.innerHTML = '';
    var sorted = Object.keys(st.wildcards).sort();
    sorted.forEach(function(name) {
        var wc = st.wildcards[name];
        var idx = indices[name] || 0;
        var pill = document.createElement('span');
        pill.className = 'preview-pill';
        pill.innerHTML = '<span class="preview-pill-name">' + name + '=</span>' +
                         '<span class="preview-pill-value">"' + (wc.values[idx] || '?') + '"</span>';
        pillsEl.appendChild(pill);
    });

    // Decomposition breakdown
    var breakdownEl = document.querySelector('[data-testid="preview-breakdown"]');
    var dims = sorted.map(function(n) { return st.wildcards[n].values.length; });
    var parts = [];
    sorted.forEach(function(name, i) {
        parts.push(name + '[' + indices[name] + '/' + dims[i] + ']');
    });
    breakdownEl.textContent = 'ID ' + st.compId + ' \u2192 ' + parts.join(' \u00d7 ');
}

function demoPreviewNext() {
    var st = demoPreviewState;
    st.compId = (st.compId + 1) % st.total;
    demoPreviewRender();
}

function demoPreviewPrev() {
    var st = demoPreviewState;
    st.compId = (st.compId - 1 + st.total) % st.total;
    demoPreviewRender();
}

function demoPreviewShuffle() {
    var st = demoPreviewState;
    st.compId = Math.floor(Math.random() * st.total);
    demoPreviewRender();
}

/** Initialize preview from Quill section state */
function initPreviewSection() {
    var st = demoPreviewState;
    st.blocks = [];
    st.wildcards = {};
    st.compId = 0;

    // Read blocks from qState
    qState.blocks.forEach(function(block) {
        var text = serializeQuill(block.quill);
        st.blocks.push({ text: text, depth: block.depth });
        block.wildcards.forEach(function(wc) {
            if (!st.wildcards[wc.name] && wc.values.length > 0) {
                st.wildcards[wc.name] = { values: wc.values.slice() };
            }
        });
    });

    // Compute total
    var total = 1;
    Object.keys(st.wildcards).forEach(function(n) {
        total *= st.wildcards[n].values.length;
    });
    st.total = Math.max(1, total);

    demoPreviewRender();
    initBucketArea();
}

/* ── Phase 2: Bucketed navigation (within same section) ── */

var demoBucketState = {
    wcMax: 2,
    bucketId: 0,
    fineIndices: {},
    totalBuckets: 1,
    blocks: [
        { text: 'Write a __tone__ email about __topic__', depth: 0 }
    ],
    wildcards: {
        tone: { values: ['formal', 'casual', 'friendly', 'professional', 'urgent', 'empathetic'] },
        topic: { values: ['pricing', 'onboarding', 'renewal', 'feedback'] }
    }
};

/** Compute bucket decomposition */
function demoBucketToIndices(bucketId, wcCounts, wcMax) {
    var sorted = Object.keys(wcCounts).sort();
    var bucketCounts = {};
    sorted.forEach(function(n) {
        bucketCounts[n] = wcMax > 0 ? Math.ceil(wcCounts[n] / wcMax) : 1;
    });
    var dims = sorted.map(function(n) { return bucketCounts[n]; });
    var total = dims.reduce(function(a, b) { return a * b; }, 1);
    var idx = total > 0 ? bucketId % total : 0;
    var indices = {};
    for (var i = sorted.length - 1; i >= 0; i--) {
        indices[sorted[i]] = idx % dims[i];
        idx = Math.floor(idx / dims[i]);
    }
    return { bucketIndices: indices, totalBuckets: total };
}

/** Get values in the current bucket window for a wildcard */
function demoBucketWindowValues(wcName, bucketIdx, wcMax) {
    var vals = demoBucketState.wildcards[wcName].values;
    var start = bucketIdx * wcMax;
    return vals.slice(start, start + wcMax);
}

/** Render bucket visualization with bracket groups */
function demoBucketRenderVisual() {
    var st = demoBucketState;
    var visualEl = document.querySelector('[data-testid="bucket-visual"]');
    visualEl.innerHTML = '';

    var wcCounts = {};
    Object.keys(st.wildcards).forEach(function(n) { wcCounts[n] = st.wildcards[n].values.length; });
    var result = demoBucketToIndices(st.bucketId, wcCounts, st.wcMax);
    st.totalBuckets = result.totalBuckets;

    var sorted = Object.keys(st.wildcards).sort();
    sorted.forEach(function(name) {
        var wc = st.wildcards[name];
        var numBuckets = Math.ceil(wc.values.length / st.wcMax);
        var activeBucket = result.bucketIndices[name];

        var row = document.createElement('div');
        row.className = 'bucket-wc-row';

        var nameEl = document.createElement('div');
        nameEl.className = 'bucket-wc-name';
        nameEl.textContent = name + ' (' + wc.values.length + ' values)';
        row.appendChild(nameEl);

        for (var b = 0; b < numBuckets; b++) {
            var group = document.createElement('span');
            group.className = 'bucket-group' + (b === activeBucket ? ' active' : '');

            var start = b * st.wcMax;
            var end = Math.min(start + st.wcMax, wc.values.length);
            for (var v = start; v < end; v++) {
                var valEl = document.createElement('span');
                valEl.className = 'bucket-val';
                if (b === activeBucket) {
                    var fineIdx = st.fineIndices[name] || 0;
                    if (v - start === fineIdx) valEl.classList.add('active');
                }
                valEl.textContent = wc.values[v];
                group.appendChild(valEl);
            }
            row.appendChild(group);
        }
        visualEl.appendChild(row);
    });
}

/** Render fine navigation dropdowns */
function demoBucketRenderFine() {
    var st = demoBucketState;
    var fineEl = document.querySelector('[data-testid="bucket-nav-fine"]');
    var label = fineEl.querySelector('.bucket-nav-label');
    fineEl.innerHTML = '';
    fineEl.appendChild(label);

    var wcCounts = {};
    Object.keys(st.wildcards).forEach(function(n) { wcCounts[n] = st.wildcards[n].values.length; });
    var result = demoBucketToIndices(st.bucketId, wcCounts, st.wcMax);

    var sorted = Object.keys(st.wildcards).sort();
    sorted.forEach(function(name) {
        var bucketIdx = result.bucketIndices[name];
        var windowVals = demoBucketWindowValues(name, bucketIdx, st.wcMax);

        var sel = document.createElement('select');
        sel.className = 'bucket-fine-select';
        sel.setAttribute('data-wc', name);
        windowVals.forEach(function(v, i) {
            var opt = document.createElement('option');
            opt.value = i;
            opt.textContent = name + ': ' + v;
            if (i === (st.fineIndices[name] || 0)) opt.selected = true;
            sel.appendChild(opt);
        });
        sel.addEventListener('change', function() {
            demoBucketFineChanged(name, parseInt(this.value, 10));
        });
        fineEl.appendChild(sel);
    });
}

/** Resolve text at current bucket position */
function demoBucketRenderResolved() {
    var st = demoBucketState;
    var wcCounts = {};
    Object.keys(st.wildcards).forEach(function(n) { wcCounts[n] = st.wildcards[n].values.length; });
    var result = demoBucketToIndices(st.bucketId, wcCounts, st.wcMax);

    var indices = {};
    var sorted = Object.keys(st.wildcards).sort();
    sorted.forEach(function(name) {
        var bucketIdx = result.bucketIndices[name];
        var fineIdx = st.fineIndices[name] || 0;
        indices[name] = bucketIdx * st.wcMax + fineIdx;
    });

    var resolvedEl = document.querySelector('[data-testid="bucket-resolved"]');
    resolvedEl.innerHTML = '';
    st.blocks.forEach(function(block, i) {
        var div = document.createElement('div');
        div.className = 'preview-block' + (block.depth > 0 ? ' preview-block-child' : '');
        div.setAttribute('data-testid', 'bucket-block-' + i);
        div.textContent = demoResolveBlock(block.text, st.wildcards, indices);
        resolvedEl.appendChild(div);
    });
}

function demoBucketRenderAll() {
    var st = demoBucketState;
    document.querySelector('[data-testid="bucket-coarse-label"]').textContent =
        (st.bucketId + 1) + ' / ' + st.totalBuckets;

    demoBucketRenderVisual();
    demoBucketRenderFine();
    demoBucketRenderResolved();
}

function demoBucketNext() {
    var st = demoBucketState;
    st.bucketId = (st.bucketId + 1) % st.totalBuckets;
    st.fineIndices = {};
    demoBucketRenderAll();
}

function demoBucketPrev() {
    var st = demoBucketState;
    st.bucketId = (st.bucketId - 1 + st.totalBuckets) % st.totalBuckets;
    st.fineIndices = {};
    demoBucketRenderAll();
}

function demoBucketFineChanged(wcName, idx) {
    demoBucketState.fineIndices[wcName] = idx;
    demoBucketRenderVisual();
    demoBucketRenderResolved();
}

function demoBucketSliderChanged(val) {
    var st = demoBucketState;
    st.wcMax = parseInt(val, 10);
    st.bucketId = 0;
    st.fineIndices = {};
    document.querySelector('[data-testid="bucket-slider-value"]').textContent = val;
    demoBucketRenderAll();
}

function initBucketArea() {
    demoBucketState.bucketId = 0;
    demoBucketState.fineIndices = {};

    var wcCounts = {};
    Object.keys(demoBucketState.wildcards).forEach(function(n) {
        wcCounts[n] = demoBucketState.wildcards[n].values.length;
    });
    var result = demoBucketToIndices(0, wcCounts, demoBucketState.wcMax);
    demoBucketState.totalBuckets = result.totalBuckets;

    demoBucketRenderAll();
}

/* ══════════════════════════════════════════════════
   SECTION 5: Annotations
   ══════════════════════════════════════════════════ */

var demoAnnState = {
    defaults: { quality: 'high', audience: 'professional', _token_limit: 500 },
    prompt: { audience: 'technical' },
    blocks: [
        {
            text: 'Write a formal email about pricing',
            annotations: { tone: 'formal', _comment: 'Main sales pitch', _priority: 'high' }
        },
        {
            text: 'Include case studies and ROI data',
            annotations: {}
        }
    ],
    tokenBudget: 500,
    activeEditor: -1
};

/** Port of annotations.js:resolve() — 3-layer merge */
function demoAnnResolve(blockIdx) {
    var merged = {};
    var sources = {};
    var k;
    // Layer 1: defaults
    for (k in demoAnnState.defaults) {
        merged[k] = demoAnnState.defaults[k];
        sources[k] = 'defaults';
    }
    // Layer 2: prompt
    for (k in demoAnnState.prompt) {
        merged[k] = demoAnnState.prompt[k];
        sources[k] = 'prompt';
    }
    // Layer 3: block
    var blockAnn = demoAnnState.blocks[blockIdx].annotations;
    for (k in blockAnn) {
        merged[k] = blockAnn[k];
        sources[k] = 'block';
    }
    // Null sentinel removal
    var computed = {};
    var removed = {};
    for (k in merged) {
        if (merged[k] === null) {
            removed[k] = sources[k];
        } else {
            computed[k] = merged[k];
        }
    }
    return { computed: computed, sources: sources, removed: removed };
}

/** Render key-value rows inside a layer body */
function demoAnnRenderKV(parentEl, obj) {
    parentEl.innerHTML = '';
    var keys = Object.keys(obj);
    if (keys.length === 0) {
        parentEl.innerHTML = '<span style="color:var(--text-muted);font-style:italic">empty</span>';
        return;
    }
    keys.forEach(function(k) {
        var row = document.createElement('div');
        row.className = 'ann-kv';
        var valDisplay = obj[k] === null ? 'null' : String(obj[k]);
        var valClass = obj[k] === null ? ' null-sentinel' : '';
        row.innerHTML = '<span class="ann-kv-key">' + k + '</span>' +
                        '<span class="ann-kv-val' + valClass + '">' + valDisplay + '</span>';
        parentEl.appendChild(row);
    });
}

/** Render the 3-layer inheritance visual for the selected block */
function demoAnnRenderLayers(blockIdx) {
    if (blockIdx === undefined) blockIdx = 0;
    demoAnnRenderKV(document.getElementById('ann-defaults-body'), demoAnnState.defaults);
    demoAnnRenderKV(document.getElementById('ann-prompt-body'), demoAnnState.prompt);
    demoAnnRenderKV(document.getElementById('ann-block-body'), demoAnnState.blocks[blockIdx].annotations);

    // Resolved
    var resolved = demoAnnResolve(blockIdx);
    var resolvedEl = document.getElementById('ann-resolved-body');
    resolvedEl.innerHTML = '';
    var keys = Object.keys(resolved.computed);
    keys.forEach(function(k) {
        var row = document.createElement('div');
        row.className = 'ann-kv';
        row.innerHTML = '<span class="ann-kv-key">' + k + '</span>' +
                        '<span class="ann-kv-val">' + String(resolved.computed[k]) + '</span>' +
                        '<span class="ann-kv-source">' + resolved.sources[k] + '</span>';
        resolvedEl.appendChild(row);
    });
    // Show removed keys
    Object.keys(resolved.removed).forEach(function(k) {
        var row = document.createElement('div');
        row.className = 'ann-kv';
        row.innerHTML = '<span class="ann-kv-key">' + k + '</span>' +
                        '<span class="ann-kv-val null-sentinel">null</span>' +
                        '<span class="ann-kv-source">' + resolved.removed[k] + '</span>';
        resolvedEl.appendChild(row);
    });
}

/** Render block cards with badges */
function demoAnnRenderBlocks() {
    var container = document.querySelector('[data-testid="ann-blocks"]');
    container.innerHTML = '';

    demoAnnState.blocks.forEach(function(block, idx) {
        var resolved = demoAnnResolve(idx);
        var card = document.createElement('div');
        card.className = 'ann-block-card';
        card.setAttribute('data-testid', 'ann-block-' + idx);
        card.setAttribute('data-path', idx);

        // Header
        var header = document.createElement('div');
        header.className = 'ann-block-header';

        var textSpan = document.createElement('span');
        textSpan.className = 'ann-block-text';
        textSpan.textContent = block.text;
        header.appendChild(textSpan);

        var badges = document.createElement('div');
        badges.className = 'ann-block-badges';

        // Annotation count badge
        var annCount = Object.keys(resolved.computed).length;
        var badge = document.createElement('span');
        badge.className = 'ann-badge';
        badge.innerHTML = '<span class="ann-badge-icon">&#9881;</span> ' + annCount;
        badges.appendChild(badge);

        // Priority pill
        if (resolved.computed._priority) {
            var pri = document.createElement('span');
            pri.className = 'ann-card-priority';
            pri.textContent = resolved.computed._priority;
            badges.appendChild(pri);
        }

        // Draft pill
        if (resolved.computed._draft) {
            var draft = document.createElement('span');
            draft.className = 'ann-card-draft';
            draft.textContent = 'draft';
            badges.appendChild(draft);
        }

        header.appendChild(badges);
        card.appendChild(header);

        // Comment
        if (resolved.computed._comment) {
            var comment = document.createElement('div');
            comment.className = 'ann-card-comment';
            comment.textContent = resolved.computed._comment;
            card.appendChild(comment);
        }

        // Editor area
        var editor = document.createElement('div');
        editor.className = 'ann-block-editor';
        card.appendChild(editor);

        // Click to toggle editor
        card.addEventListener('click', function(e) {
            if (e.target.closest('.ann-editor-row') || e.target.closest('.ann-editor-actions')) return;
            demoAnnToggleEditor(idx, card);
        });

        container.appendChild(card);
    });
}

/** Toggle annotation editor for a block */
function demoAnnToggleEditor(blockIdx, card) {
    var editor = card.querySelector('.ann-block-editor');
    var isOpen = editor.classList.contains('open');

    // Close all editors first
    document.querySelectorAll('.ann-block-editor.open').forEach(function(el) {
        el.classList.remove('open');
        el.innerHTML = '';
    });

    if (isOpen) {
        demoAnnState.activeEditor = -1;
        return;
    }

    demoAnnState.activeEditor = blockIdx;
    demoAnnRenderLayers(blockIdx);

    var resolved = demoAnnResolve(blockIdx);
    var blockAnn = demoAnnState.blocks[blockIdx].annotations;
    editor.innerHTML = '';

    // Show all resolved keys as editor rows
    var allKeys = Object.keys(resolved.computed).concat(Object.keys(resolved.removed));
    var unique = [];
    allKeys.forEach(function(k) { if (unique.indexOf(k) === -1) unique.push(k); });

    unique.forEach(function(k) {
        var row = document.createElement('div');
        row.className = 'ann-editor-row';
        var isOwn = blockAnn.hasOwnProperty(k);
        var isNull = blockAnn[k] === null;
        var source = resolved.sources[k] || 'removed';

        if (isNull) {
            row.classList.add('null-override');
        } else if (!isOwn) {
            row.classList.add('inherited');
        }

        var keyEl = document.createElement('span');
        keyEl.className = 'ann-editor-key';
        keyEl.textContent = k;
        row.appendChild(keyEl);

        if (isNull) {
            var nullLabel = document.createElement('span');
            nullLabel.className = 'ann-editor-val';
            nullLabel.textContent = 'null (removed)';
            row.appendChild(nullLabel);

            var restoreBtn = document.createElement('span');
            restoreBtn.className = 'ann-restore-btn';
            restoreBtn.textContent = 'restore';
            restoreBtn.addEventListener('click', function(e) {
                e.stopPropagation();
                delete blockAnn[k];
                demoAnnRefresh(blockIdx, card);
            });
            row.appendChild(restoreBtn);
        } else if (isOwn) {
            var input = document.createElement('input');
            input.className = 'ann-editor-val';
            input.value = String(resolved.computed[k]);
            input.addEventListener('change', function() {
                blockAnn[k] = this.value;
                demoAnnRefresh(blockIdx, card);
            });
            row.appendChild(input);
        } else {
            var valEl = document.createElement('span');
            valEl.className = 'ann-editor-val';
            valEl.textContent = String(resolved.computed[k]);
            row.appendChild(valEl);
        }

        var sourceEl = document.createElement('span');
        sourceEl.className = 'ann-editor-source';
        sourceEl.textContent = source;
        row.appendChild(sourceEl);

        editor.appendChild(row);
    });

    // Action buttons
    var actions = document.createElement('div');
    actions.className = 'ann-editor-actions';

    var addBtn = document.createElement('button');
    addBtn.className = 'ann-editor-btn';
    addBtn.textContent = '+ Add';
    addBtn.addEventListener('click', function(e) {
        e.stopPropagation();
        var key = prompt('Annotation key:');
        if (key) {
            var val = prompt('Value (leave empty for null sentinel):');
            blockAnn[key] = val === '' ? null : val;
            demoAnnRefresh(blockIdx, card);
        }
    });
    actions.appendChild(addBtn);

    var nullBtn = document.createElement('button');
    nullBtn.className = 'ann-editor-btn';
    nullBtn.textContent = 'Set null';
    nullBtn.addEventListener('click', function(e) {
        e.stopPropagation();
        var key = prompt('Key to set null (removes inherited value):');
        if (key) {
            blockAnn[key] = null;
            demoAnnRefresh(blockIdx, card);
        }
    });
    actions.appendChild(nullBtn);

    editor.appendChild(actions);

    // Open with animation
    requestAnimationFrame(function() { editor.classList.add('open'); });
}

/** Refresh after annotation edit */
function demoAnnRefresh(blockIdx, card) {
    // Re-render blocks and re-open editor
    demoAnnRenderBlocks();
    var newCard = document.querySelector('[data-testid="ann-block-' + blockIdx + '"]');
    if (newCard) demoAnnToggleEditor(blockIdx, newCard);
}

/** Token counter: ~4 chars per token */
function demoComputeTokens(text) { return Math.ceil(text.length / 4); }

function demoTokenUpdate(text) {
    var tokens = demoComputeTokens(text);
    var budget = demoAnnState.tokenBudget;
    var chip = document.querySelector('[data-testid="ann-token-chip"]');
    chip.textContent = '~' + tokens + '/' + budget;
    chip.className = 'ann-token-chip';
    var ratio = tokens / budget;
    if (ratio >= 1) chip.classList.add('over');
    else if (ratio >= 0.8) chip.classList.add('warn');
    else chip.classList.add('ok');
}

function demoTokenBudgetChanged(val) {
    demoAnnState.tokenBudget = parseInt(val, 10) || 500;
    var textarea = document.querySelector('[data-testid="ann-token-textarea"]');
    demoTokenUpdate(textarea.value);
}

function initAnnSection() {
    demoAnnRenderLayers(0);
    demoAnnRenderBlocks();
    var textarea = document.querySelector('[data-testid="ann-token-textarea"]');
    demoTokenUpdate(textarea.value);
}

/* ══════════════════════════════════════════════════
   SECTION TRANSITIONS
   ══════════════════════════════════════════════════ */

// Section 2 → Section 3 (Navigating Compositions — flat + buckets)
document.getElementById('quill-save-btn').addEventListener('click', function() {
    initPreviewSection();
    document.getElementById('preview-section').style.display = '';
    document.getElementById('preview-section').scrollIntoView({ behavior: 'smooth' });
});

// Section 3 → Section 4 (Annotations)
document.getElementById('preview-continue-btn').addEventListener('click', function() {
    initAnnSection();
    document.getElementById('ann-section').style.display = '';
    document.getElementById('ann-section').scrollIntoView({ behavior: 'smooth' });
});
</script>
</body>
</html>
